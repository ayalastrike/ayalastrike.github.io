<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rick&#39;s Blog</title>
    <link>https://ayalastrike.github.io/</link>
    <description>Recent content on Rick&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://ayalastrike.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/about/</guid>
      <description>Email: tianjiawei@gmail.com</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/InnoDB/1_overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/InnoDB/1_overview/</guid>
      <description>Heikki Tuuri是InnoDB存储引擎的创始人，1964年生于芬兰赫尔辛基。与著名Linux操作系统的创始人Linus一样毕业于芬兰赫尔辛基大学。从入学时间来看，Heikki Tuuri还是Linus的学长。在1990年取得赫尔辛基大学的数理逻辑博士学位后。
所以，innodb的代码大部分都是Created mm/dd/YYYY Heikki Tuuri。
MySQL大事时间表：
 1995：Heikki Tuuri成立Innobase Oy公司并担任CEO。同年，由David Axmark、Allan Larsson和Michael Monty Widenius在瑞典创办MySQL AB公司。 2001：Innobase公司开始与MySQL AB公司进行合作并开源InnoDB存储引擎的代码。 2005：Oracle公司收购了Innobase公司。 2008：Sun收购MySQL AB公司。 2009：2009年4月20日，Sun 公司董事会通过决议，同意以每股9.5美元的价格将公司出售给Oracle。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/InnoDB/2_source/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/InnoDB/2_source/</guid>
      <description>typora-root-url: ../../../../static
在MySQL源代码中，每个模块都有自己单独的目录存放，里面按照模块名0子模块名.cc来组织。所有头文件都放在include目录下，同时include目录下还有*.ic的文件，这个文件中存放定义的内联函数。
如果要在*.ic中使用宏UNIV_INLINE定义内联，需要#include &amp;ldquo;univ.i&amp;rdquo;，即
#include &amp;#34;univ.i&amp;#34;UNIV_INLINE return_value function foo(param1, ...) ``// 函数声明或实现 { ``... } 注意，这种风格只是适用于c函数，对于ic文件中的类成员函数定义，还是需要手动写inline  univ.i中UNIV_INLINE的宏定义
#ifndef UNIV_MUST_NOT_INLINE /* Definition for inline version */ #define UNIV_INLINE static inline #else /* !UNIV_MUST_NOT_INLINE *//* If we want to compile a noninlined version we use the following macro definitions: */ #define UNIV_NONINL #define UNIV_INLINE #endif /* !UNIV_MUST_NOT_INLINE */阅读源码层次
推荐从下至上进行逐层阅读
最下一层是基础管理模块：
 File Manager主要封装了InnoDB对于文件的各类操作，如读、写、异步I/O等。 Concurrency Manager模块主要封装了引擎内部使用的各类mutex和latch。 Common Utility模块用于一些基本数据结构与算法的定义，如链表、哈希表等。  图中间虚线标注的部分为InnoDB的内核实现，也就是InnoDB存储引擎中的事务、锁、缓冲区、日志、存储管理、资源管理、索引、change buffer模块，这部分是整个存储引擎的核心。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/InnoDB/3_basic_structure_algo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/InnoDB/3_basic_structure_algo/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/InnoDB/4_os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/InnoDB/4_os/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/InnoDB/5_record/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/InnoDB/5_record/</guid>
      <description>设计 #  MySQL主要面向的是OLTP场景，所以数据记录采用行存（NSM - n-ary storage model）。
基于行进行存储有以下几个好处：
 记录存放在一个页中，存储一条记录需要访问的页面较少 符合传统机械硬盘的访问方式 易于理解，数据的存取就像是对一张二维表进行访问  在整体上看，表中的数据是按照如下形式组织的：
那我们如何来理解记录呢？
首先，在关系数据库系统理论中，通常用元组（tuple）描述记录，用字段（field）描述列，每个元组由多个字段组成，每个表由多个元组组成。
行和元组在意义上是相等的。但是更愿意将行（row）理解为物理记录，将元组（tuple）理解为逻辑记录。物理记录为行实际存放在物理存储中的格式，其内容由二进制字符串组成，可读性差。逻辑记录则容易理解的多，每张表中的多个记录就像是一个数组。由于其只是“逻辑”上的含义，因此逻辑记录只是物理记录在内存中的表现形式，实际并不占用任何的物理存储空间。
关系如下图所示：
物理记录和逻辑记录的差异如下：
    物理记录 逻辑记录     可读性 差 好   存储位置 磁盘 内存   亲和性 对存储友好（更紧凑） 对查找友好（更易寻址）   存储内容 除记录中的列数据外，还有一些额外信息 元组    这两种记录之间本身可以互相转换。比如，在插入一条记录时，原来没有数据，首先需要根据插入的记录构造一个逻辑记录，然后再存放到磁盘上。对于读取，要从磁盘上seek出来相应的数据页，再将页中的物理记录转换成逻辑记录展现给用户。
除此之外，在MySQL server层也需要在binlog中记录数据的变化，也需要一种行格式。因此，在MySQL中，行格式一共有3种存储方式：
 Server层格式：与存储引擎无关，server层的binlog行格式（Row-Base Replication下的binlog格式） 逻辑记录格式：tuple，也称为索引元组格式（因为InnoDB是IOT）。在同一个表中，不同索引对应的元组是不同的 物理记录格式：record，也称为physical record  物理记录的设计 #  物理记录承载着数据的最终存储，因此，我们首先讨论物理记录。
磁盘上的物理记录需要面向计算机友好，更紧凑、强调IO性能，以及在此基础上支持事务语义。
目标：
 描述行存的数据 适配存储引擎的结构 查找快 DML快 事务语义 更少的资源占用（disk、buffer pool、update I/O）  逻辑记录的设计 #  磁盘上的物理记录面向的是计算机友好的，更紧凑、高IO性能。同时，为了性能的考虑，数据也需要常驻内存（buffer pool），所以需要设计数据结构用于表述记录，这被称为tuple（元组），也称为逻辑记录。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/InnoDB/6_page/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/InnoDB/6_page/</guid>
      <description>索引页 #  InnoDB存储引擎是索引组织表，因此聚簇索引页的叶子节点中存放完整的数据记录，辅助索引页的叶子节点中存放指向聚簇索引页叶子节点的书签（bookmark），也可以称为路标。
主要是两部分：
 page layout scan rec with cursor, and then insert, update, delete  1. 页 #  页是InnoDB存储引擎的最小存储单位。页的大小可以设置为4K、8K、16K、32K、64K，默认为16K，页的大小设置要考虑IO性能，也会影响到区的分配大小和重做日志缓冲的大小，详见innodb_page_size。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/Server/8.0_net_optimize/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/Server/8.0_net_optimize/</guid>
      <description>Administrative Connection Management #  如果MySQL连接连接被打满，有时甚至连root也无法登录去kill。
对于这个问题，目前已有的解法有：
 各家的线程池提供了extra_port。 Alibaba RDS MySQL的做法是把connection的个数拆分成不同的使用目的，例如系统维护账户占用一部分，用户账户占用一部分，两者不互相影响。  MySQL 8.0提供了administrative-connection-interface的机制（由facebook贡献），即提供单独的network interface并且可以单独配置一个pthread用于listen。
参数如下：
 admin_address admin_port create_admin_listener_thread：是否创建一个单独的listener线程来监听admin的链接请求（默认OFF，建议打开）  worklog：WL#12138: Add Admin Port
代码
Multiple addresses for the –bind-address #  bind-address支持绑定多个网络地址。比如：
// The server listens on the 198.51.100.20 IPv4 address and the 2001:db8:0:f101::1 IPv6 address. bind_address=198.51.100.20,2001:db8:0:f101::1 worklog：WL#11652: Support multiple addresses for the &amp;ndash;bind-address command option
代码
connect/disconnect performance #  目前MySQL里是使用一个全局大锁（LOCK_thd_list、LOCK_thd_remove）来保护thd_list。
优化的思路其实很简单直接：分区，将LOCK_thd_list、LOCK_thd_remove根据thread id来分成8个分区（hardcode）来减少冲突，负面影响就是PS的监控数据需要聚合。
worklog：WL#9250: Split LOCK_thd_list and LOCK_thd_remove mutexes</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/Server/8.0_resource_group/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/Server/8.0_resource_group/</guid>
      <description>ＭySQL8.0增加了一个新功能resource group，可以对不同的用户进行资源控制，例如对用户线程和后台系统线程给予不同的CPU优先级。
用户可以通过SQL接口创建不同的分组，这些分组可以作为sql的hit，也可以动态的绑定过去。本文主要简单介绍下用法，至于底层如何实现的，其实比较简单：创建的分组被存储到系统表中；在linux系统底层通过CPU_SET来绑定CPU，通过setpriority来设置线程的nice值
worklog: WL#9467: Resource Groups
创建resource group #  系统自带两个resource group（不可修改）：
 FOREGROUND (FG) - &amp;ldquo;user&amp;rdquo; threads BACKGROUND (BG) - &amp;ldquo;system&amp;rdquo; threads (internal Engine threads, e.g. &amp;ldquo;purge&amp;quot;in InnoDB, etc.)  mysql&amp;gt; SELECT * FROM INFORMATION_SCHEMA.RESOURCE_GROUPS\G *************************** 1. row *************************** RESOURCE_GROUP_NAME: USR_default RESOURCE_GROUP_TYPE: USER RESOURCE_GROUP_ENABLED: 1 VCPU_IDS: 0-63 THREAD_PRIORITY: 0 *************************** 2. row *************************** RESOURCE_GROUP_NAME: SYS_default RESOURCE_GROUP_TYPE: SYSTEM RESOURCE_GROUP_ENABLED: 1 VCPU_IDS: 0-63 THREAD_PRIORITY: 0 2 rows in set (0.00 sec) 只有超级账户启动mysqld才能设置thread priority，否则只能降低而不能提升优先级。（-20最高，20最低）</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/Server/connection_handler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/Server/connection_handler/</guid>
      <description>概述 #  在MySQL中，对于client发来的请求，其处理流程分为建链和请求处理两部分，这两个阶段分别称为connection phase和command phase。
MySQL的server-client protocol交互如下：
从上图中可以看出，connection phase负责连接的建立，而日常的query处理，则称为command phase，command phase的结束，以COM_QUIT query的到来作为标志。
一般典型的交互过程是connect，query，query，query&amp;hellip; quit，其中query可以是dml、ddl、multi-statement或是prepared statement。
下面我们先看一下connection phase。
建链 #  connection phase用于在client-server间建立连接，而建链分为TCP建链和应用建链。
TCP建链是指TCP socket的listen、accept。
应用建链是在TCP建链的基础上，通过应用层协议进行认证：server发送handshake（initial handshake）、客户端回username/pwd（handshake response），server回应是否通过认证（OK/Error）。
我们接下来首先看一下connection phase，即在MySQL中如何处理TCP建链和应用建链的。
TCP建链 #  TCP连接处理分为两步：
 初始化，创建conn_mgr和conn_handler，acceptor和listener 监听建链，由acceptor+listener负责 对已建链连接进行线程分发处理，由conn_mgr+conn_handler负责  整体流程如下图所示：
代码实现
mysqld_main init_common_variables Connection_handler_manager::init() // 初始化conn_mgr和conn_handler  network_init()	// 初始化网络 	set_ports();	// 设置port  // 初始化acceptor、listener 	Mysqld_socket_listener *mysqld_socket_listener= new (std::nothrow) Mysqld_socket_listener(bind_addr_str, mysqld_port, back_log, mysqld_port_timeout, unix_sock_name); Connection_acceptor&amp;lt;Mysqld_socket_listener&amp;gt; *mysqld_socket_acceptor= new (std::nothrow) Connection_acceptor&amp;lt;Mysqld_socket_listener&amp;gt;(mysqld_socket_listener); mysqld_socket_acceptor-&amp;gt;init_connection_acceptor(); .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/Server/mariadb_maxscale_proxy_protocol/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/Server/mariadb_maxscale_proxy_protocol/</guid>
      <description>MariaDB MaxScale 是一款数据库中间件，可以按照语义分发语句到多个数据库服务器上。它对应用程序透明，可以提供读写分离、负载均衡和高可用服务。
proxy protocol 是 MaxScale 引入，为了解决使用proxy作为中间件连接mysql时，mysql获取client ip用 client通过proxy中间价连接mysql时，mysql server接收到认证报文中，包含的是proxy节点的IP。如果mysql.user表中指定了client的IP，无法通过认证。
一种传统处理方式是在proxy节点上保存client的ip和密码，用于client的认证，而在mysql server上使用另一套ip和密码用于proxy 节点到mysql server的认证。
MariaDB MaxScale引入了proxy protocol来解决client ip透传的问题。proxy节点获取到client ip后，把client ip包装在proxy protocol报文中发给server，server解析到了proxy protocol报文，再用报文中的ip替换proxy节点的ip
因为 proxy protocol 本身不包含鉴权，同时可能影响数据库的鉴权行为，所以在数据库 server 端设置了一个ip白名单，只有白名单ip发送的 proxy protocol 报文才会被接受。
报文格式 #  proxy protocol 有两个版本 v1 和 v2 通过报文签名区分
v1 #  v1 报文是字符串形式 “PROXY %s %s %s %d %d”
   字段 内容     签名 PROXY   %s.1 address family   %s.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/Server/mdl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/Server/mdl/</guid>
      <description>历史 #  为了解这个著名的bug#989：
DML和DDL如果并发执行，binlog序错乱：主库并发执行了DDL（T → T&#39;）和DML（T’），但是提交到了binlog中顺序是DDL+DML，这样在从库上回放时，先执行DDL，后执行DML，但此时表结构已经变为T‘，DML执行失败  因此，在MySQL 5.5中，引入了MDL（Meta Data Lock）来控制DDL和DML的并发，保证元数据的一致性。
设计思理：
 WL#3726：DDL locking for all metadata objects WL#4284：Transactional DDL locking  谈到MDL，需要先谈谈MySQL的锁定机制设计以及thr_lock
MySQL locking #  为了保证数据的一致性和完整性，数据库系统普遍存在封锁机制，而封锁机制的优劣直接关系到数据库系统的并发处理能力和性能，所以封锁机制的实现也成为了各种数据库的核心技术之一。
MySQL的封锁机制有三种：
 row-level locking：InnoDB、NDB Cluster table-level locking：MyISAM、MEMORY、MERGE、CSV等非事务存储引擎 page-level locking：BerkeleyDB  MySQL采用如此多样的封锁机制是由其产品定位和发展历史共同决定的。首先，MySQL的产品定位是通过plugin机制可以接入多个存储引擎。在早期的存储引擎（MyISAM和MEMORY）设计中，设计原则建立在&amp;quot;任何表在同一时刻都只允许单个线程（无论读写）对其访问&amp;quot;之上。随后，MySQL3.23修正了之前的假设：MyISAM支持Concurrent Insert：如果没有hole，可以多个读线程并发读同一张表，同时多个写线程以队列的形式进行尾部insert。之后，BerkeleyDB和InnoDB的引入也挑战了之前的设计假设，要求page-level、和row-level locking。此时，之前的设计方式已经和存储引擎所提供的能力不相衬了。因此MySQL做出了改变，允许存储引擎自己改变MySQL 通过接口传入的锁定类型（也就是上面的3种）而自行决定该怎样封锁数据。
MySQL加锁的顺序
SQL → open table → 加MDL锁 → 加表锁 → 加InnoDB锁 → SQL执行 → 释放MDL锁 → 释放表锁 → 释放InnoDB锁
其中表锁是通过thr_lock提供的，在MySQL 5.7.5中，thr_lock被MDL替换：
Scalability for InnoDB tables was improved by avoiding THR_LOCK locks.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/Server/net/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/Server/net/</guid>
      <description>MySQL packet的结构如下：
packet length (3 bytes) // 数据
packet number (1 byte) // 保序
compression length (3 bytes) optional // 压缩
compression packet number （1 byte） optional // 保序
packet data
 因为采用3个字节存储包的长度，所以支持的包最大为 MAX_PACKET_LENGTH (256L256L256L-1)。如果数据流超过包最大值（16M），则通过packet number（ne→pkt_nr）保序。
发包 #  my_net_write #  发包，Write a logical packet with packet header.
net_write_buff #  发送缓冲区，Caching the data in a local buffer before sending it.
每个Net对象有一个buffer(net-&amp;gt;buff)，即将发送的数据被拷贝到这个buffer中。如果buffer未满则进行memcpy，并更新写入点位（net-&amp;gt;write_pos）；满了当Buffer满时需要立刻发出到客户端（net_write_packet）。
net_write_packet #  socket写数据，Write a MySQL protocol packet to the network handler.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/Server/protocol/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/Server/protocol/</guid>
      <description>MySQL client-server protocol：https://dev.mysql.com/doc/internals/en/client-server-protocol.html
MySQL 5.7重构了Protocol模块
我们在这里主要聚焦在command phase，即MySQL server和client如何处理query的交互。
我们从MySQL协议可以知道，在query的交互上，一般采用ping-pong模型，即：
 client-&amp;gt;server：发query server-&amp;gt;client：回包  所以我们在下面详细拆解这两个阶段。
读取query #  当client发送一条query后，server对query进行以下处理：
 读包 解析包体 根据命令指派执行  数据报文包括包头+包体，包头已在读包内部验证后丢弃（read_packet），然后包体返回给Protocol_classic::get_command封装为raw_packet。从raw_packet[0]中判断query的命令号，进行报文解析（parse_packet），拆解为COM_DATA（根据命令号封装了不同的struct）。
do_command // conn_handler Protocol_classic::get_command // 读包 Protocol_classic::read_packet my_net_read // 处理多包、压缩包 net_read_packet // 将读到的数据填充到NET中 Protocol_classic::parse_packet // 解析包体 dispatch_command // 根据命令指派执行 回包 #  返回的报文类型有：OK Packet，Error Packet和结果集包（Data Packet，EOF Packet）。
OK Packet #  do_command dispatch_command THD::send_statement_status // 根据这条statement执行的情况确定回包类型 Protocol_classic::send_ok // 回OK包 Error Packet #  do_command dispatch_command THD::send_statement_status // 根据这条statement执行的情况确定回包类型 Protocol_classic::send_error // 回错误包 结果集包 #  结果集包的结构如下:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/Server/returning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/Server/returning/</guid>
      <description>背景 #  MySQL对于statement执行结果报文通常分为两类：Resultset和OK/ERR，针对 DML语句则返回OK/ERR报文，其中包括几个影响记录，扫描记录等属性。但在很多业务场景下，通常 INSERT/UPDATE/DELETE 这样的DML语句后，都会跟随SELECT查询当前记录内容，以进行接下来的业务处理， 为了减少一次 Client &amp;lt;-&amp;gt; DB Server 交互，类似 PostgreSQL / Oracle 都提供了 returning clause 支持 DML 返回 Resultset。
AliSQL 为了减少对 MySQL 语法兼容性的侵入，并支持 returning 功能， 采用了 native procedure 的方式，使用DBMS_TRANS package，统一使用 returning procedure 来支持 DML 语句返回 Resultset。
语法 #  DBMS_TRANS.returning(Field_list=&amp;gt;, Statement=&amp;gt;); 其中:
 Field list : 代表期望的返回字段，以 “,” 进行分割，支持 * 号表达； Statement ：表示要执行的DML 语句， 支持 INSERT / UPDATE / DELETE；  INSERT Returning #  针对 insert 语句， returning proc 返回插入到表中的记录内容；</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/Server/startup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/Server/startup/</guid>
      <description>MySQL启动过程
main() // 入口 sql/main.cc mysqld_main() // sql/mysqld.cc // 记录入参 my_progname = argv[0]; orig_argc = argc; orig_argv = argv; // 处理配置文件my.cnf及启动参数 load_defaults(MYSQL_CONFIG_NAME, load_default_groups, &amp;amp;argc, &amp;amp;argv, &amp;amp;argv_alloc); // 继续处理启动参数，为初始化系统表做准备 sys_var::m_parse_flag == PARSE_EARLY handle_early_options(); // 为status统计计数做准备 init_sql_statement_names(); // 初始化system variables哈希表,链表sys_var_chain sys_var,遍历链表后,加入到system_variable_hash哈希表 // sys_var_chain链表已经通过sys_vars.cc的sys_var()构造函数static初始化 sys_var_init(); // 计算打开文件数并初始化table cache adjust_related_options(&amp;amp;requested_open_files); // init error log global variables init_error_log(); // init audit global variables mysql_audit_initialize(); // 初始化query log和slow log query_logger.init(); // 初始化system variables init_common_variables(); default_storage_engine= const_cast&amp;lt;char *&amp;gt;(&amp;quot;InnoDB&amp;quot;); // 设置默认storage engine add_status_vars(status_vars); // 初始化status变量(show status), status_vars为全局变量 set_server_version(); get_options(&amp;amp;remaining_argc, &amp;amp;remaining_argv); // sys_var::m_parse_flag == PARSE_NORMAL // 设置thread_cache_size init_client_errs(); // 读出给client返回出错信息的文件 lex_init(); // 初始化词法分析 item_create_init(); // 初始化函数列表 func_array为全局变量 // 设置默认字符集和校验字符集 global_system_variables.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/Server/thd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/Server/thd/</guid>
      <description>THD对象 #  THD封装了线程相关的数据，可以视作一个处理单元。
The size of the THD is ~10K and its definition is found in sql_class.h.
The THD is a large data structure which is used to keep track of various aspects of execution state. Memory rooted in the THD will grow significantly during query execution, but exactly how much it grows will depend upon the query. For memory planning purposes we recommend to plan for ~10MB per connection on average.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/Server/ThreadPool/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/Server/ThreadPool/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/Server/timeout/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/Server/timeout/</guid>
      <description>背景 #  在分布式环境下，异步网络是一个挑战，当遇到网络问题时，提供超时机制可以提升系统的可用性。并且，对于事务系统，锁机制也需要超时机制来保证资源可以在有限时间内释放，避免饥饿现象的产生。
为此，MySQL在多种场景下提供了timeout机制。
简单一句话，MySQL Protocol ping-pong模型各个节点都有超时检测  MySQL timeout配置 #  MySQL内有多种timeout，我们先看一下有多少：
mysql&amp;gt; show global variables like &#39;%timeout%&#39;; +-----------------------------+----------+ | Variable_name | Value | +-----------------------------+----------+ | connect_timeout | 5 | | net_read_timeout | 30 | | net_write_timeout | 60 | | wait_timeout | 28800 | | interactive_timeout | 28800 | | lock_wait_timeout | 31536000 | | innodb_lock_wait_timeout | 3 | | innodb_rollback_on_timeout | OFF | +-----------------------------+----------+ 通过阅读官方文档，结合我们在下面对于timeout实现的论证，这里先放上结论：
网络超时</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/Server/vio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/Server/vio/</guid>
      <description>VIO模块 #  为不同的protocol提供network I/O wrapper，类似于winsock。
Virtual I/O Library.
The VIO routines are wrappers for the various network I/O calls that happen with different protocols. The idea is that in the main modules one won&amp;rsquo;t have to write separate bits of code for each protocol. Thus vio&amp;rsquo;s purpose is somewhat like the purpose of Microsoft&amp;rsquo;s winsock library. https://dev.mysql.com/doc/internals/en/vio-directory.html
 SOCKET封装了socket fd，里面只有fd信息。
目前支持的protocol：
 TCP/IP Unix domain socket Named Pipes（Windows only） Shared Memory（Windows only） Secure Sockets（SSL）  Unix domain socket</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/menu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/menu/</guid>
      <description> MySQL  Server  MySQL启动过程 MySQL的连接和请求处理  THD Protocol  Returning   NET VIO MySQL 8.0 对网络模块的优化 MySQL 8.0 通过Resource Group来控制线程计算资源 MariaDB MaxScale Proxy Protocol   Timeout机制 Thread Pool MDL   InnoDB  概览 源码结构 基本数据结构和算法 os record page      </description>
    </item>
    
  </channel>
</rss>
