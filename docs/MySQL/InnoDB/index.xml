<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rick&#39;s Blog</title>
    <link>https://ayalastrike.github.io/docs/MySQL/InnoDB/</link>
    <description>Recent content on Rick&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://ayalastrike.github.io/docs/MySQL/InnoDB/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/InnoDB/1_overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/InnoDB/1_overview/</guid>
      <description>Heikki Tuuri是InnoDB存储引擎的创始人，1964年生于芬兰赫尔辛基。与著名Linux操作系统的创始人Linus一样毕业于芬兰赫尔辛基大学。从入学时间来看，Heikki Tuuri还是Linus的学长。在1990年取得赫尔辛基大学的数理逻辑博士学位后。
所以，innodb的代码大部分都是Created mm/dd/YYYY Heikki Tuuri。
MySQL大事时间表：
 1995：Heikki Tuuri成立Innobase Oy公司并担任CEO。同年，由David Axmark、Allan Larsson和Michael Monty Widenius在瑞典创办MySQL AB公司。 2001：Innobase公司开始与MySQL AB公司进行合作并开源InnoDB存储引擎的代码。 2005：Oracle公司收购了Innobase公司。 2008：Sun收购MySQL AB公司。 2009：2009年4月20日，Sun 公司董事会通过决议，同意以每股9.5美元的价格将公司出售给Oracle。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/InnoDB/2_source/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/InnoDB/2_source/</guid>
      <description>typora-root-url: ../../../../static
在MySQL源代码中，每个模块都有自己单独的目录存放，里面按照模块名0子模块名.cc来组织。所有头文件都放在include目录下，同时include目录下还有*.ic的文件，这个文件中存放定义的内联函数。
如果要在*.ic中使用宏UNIV_INLINE定义内联，需要#include &amp;ldquo;univ.i&amp;rdquo;，即
#include &amp;#34;univ.i&amp;#34;UNIV_INLINE return_value function foo(param1, ...) ``// 函数声明或实现 { ``... } 注意，这种风格只是适用于c函数，对于ic文件中的类成员函数定义，还是需要手动写inline  univ.i中UNIV_INLINE的宏定义
#ifndef UNIV_MUST_NOT_INLINE /* Definition for inline version */ #define UNIV_INLINE static inline #else /* !UNIV_MUST_NOT_INLINE *//* If we want to compile a noninlined version we use the following macro definitions: */ #define UNIV_NONINL #define UNIV_INLINE #endif /* !UNIV_MUST_NOT_INLINE */阅读源码层次
推荐从下至上进行逐层阅读
最下一层是基础管理模块：
 File Manager主要封装了InnoDB对于文件的各类操作，如读、写、异步I/O等。 Concurrency Manager模块主要封装了引擎内部使用的各类mutex和latch。 Common Utility模块用于一些基本数据结构与算法的定义，如链表、哈希表等。  图中间虚线标注的部分为InnoDB的内核实现，也就是InnoDB存储引擎中的事务、锁、缓冲区、日志、存储管理、资源管理、索引、change buffer模块，这部分是整个存储引擎的核心。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/InnoDB/3_basic_structure_algo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/InnoDB/3_basic_structure_algo/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/InnoDB/4_os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/InnoDB/4_os/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/InnoDB/5_record/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/InnoDB/5_record/</guid>
      <description>设计 #  MySQL主要面向的是OLTP场景，所以数据记录采用行存（NSM - n-ary storage model）。
基于行进行存储有以下几个好处：
 记录存放在一个页中，存储一条记录需要访问的页面较少 符合传统机械硬盘的访问方式 易于理解，数据的存取就像是对一张二维表进行访问  在整体上看，表中的数据是按照如下形式组织的：
那我们如何来理解记录呢？
首先，在关系数据库系统理论中，通常用元组（tuple）描述记录，用字段（field）描述列，每个元组由多个字段组成，每个表由多个元组组成。
行和元组在意义上是相等的。但是更愿意将行（row）理解为物理记录，将元组（tuple）理解为逻辑记录。物理记录为行实际存放在物理存储中的格式，其内容由二进制字符串组成，可读性差。逻辑记录则容易理解的多，每张表中的多个记录就像是一个数组。由于其只是“逻辑”上的含义，因此逻辑记录只是物理记录在内存中的表现形式，实际并不占用任何的物理存储空间。
关系如下图所示：
物理记录和逻辑记录的差异如下：
    物理记录 逻辑记录     可读性 差 好   存储位置 磁盘 内存   亲和性 对存储友好（更紧凑） 对查找友好（更易寻址）   存储内容 除记录中的列数据外，还有一些额外信息 元组    这两种记录之间本身可以互相转换。比如，在插入一条记录时，原来没有数据，首先需要根据插入的记录构造一个逻辑记录，然后再存放到磁盘上。对于读取，要从磁盘上seek出来相应的数据页，再将页中的物理记录转换成逻辑记录展现给用户。
除此之外，在MySQL server层也需要在binlog中记录数据的变化，也需要一种行格式。因此，在MySQL中，行格式一共有3种存储方式：
 Server层格式：与存储引擎无关，server层的binlog行格式（Row-Base Replication下的binlog格式） 逻辑记录格式：tuple，也称为索引元组格式（因为InnoDB是IOT）。在同一个表中，不同索引对应的元组是不同的 物理记录格式：record，也称为physical record  物理记录的设计 #  物理记录承载着数据的最终存储，因此，我们首先讨论物理记录。
磁盘上的物理记录需要面向计算机友好，更紧凑、强调IO性能，以及在此基础上支持事务语义。
目标：
 描述行存的数据 适配存储引擎的结构 查找快 DML快 事务语义 更少的资源占用（disk、buffer pool、update I/O）  逻辑记录的设计 #  磁盘上的物理记录面向的是计算机友好的，更紧凑、高IO性能。同时，为了性能的考虑，数据也需要常驻内存（buffer pool），所以需要设计数据结构用于表述记录，这被称为tuple（元组），也称为逻辑记录。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ayalastrike.github.io/docs/MySQL/InnoDB/6_page/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ayalastrike.github.io/docs/MySQL/InnoDB/6_page/</guid>
      <description>索引页 #  InnoDB存储引擎是索引组织表，因此聚簇索引页的叶子节点中存放完整的数据记录，辅助索引页的叶子节点中存放指向聚簇索引页叶子节点的书签（bookmark），也可以称为路标。
主要是两部分：
 page layout scan rec with cursor, and then insert, update, delete  1. 页 #  页是InnoDB存储引擎的最小存储单位。页的大小可以设置为4K、8K、16K、32K、64K，默认为16K，页的大小设置要考虑IO性能，也会影响到区的分配大小和重做日志缓冲的大小，详见innodb_page_size。</description>
    </item>
    
  </channel>
</rss>
