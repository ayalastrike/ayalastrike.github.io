<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="1 事务 #  1.1 概述 #  事务是访问数据库中数据的一个程序执行单元。在一个事务中的操作，要么都做，要么不做，这是事务的目的，也是事务模型区别于文件系统的重要特征之一。
从理论上来说，事务有着极其严格的定义，必须同时满足ACID四个特性。但是数据库厂商出于各种目的，并没有严格满足事务的ACID标准。比如对于MySQL的NDB Cluster，没有满足D；对于Oracle，默认的事务隔离级别是Read Committed，不满足I。在InnoDB中，默认的事务隔离级别是Read Repeatable，完全遵循和满足事务的ACID特性。
这里要注意，D保证的是事务系统的高可靠性（High Reliability），而不是高可用性（High Availability）。对于高可用性，事务本身并不能保证，需要一些系统共同配合来完成。
1.2 分类 #  参见Jim Gray
1.3 隔离级别 #  令人惊讶的是，大部分数据库系统都没有提供真正的隔离性，最初或许是因为系统实现者并没有真正理解这些问题。如今这些问题已经弄清楚了，但是数据库的实现者在正确性和性能之间做了妥协。ISO和ANSI SQL标准制定了四种事务隔离级别的标准，但是很少有数据库厂商遵循这些标准，比如Oracle不支持Read Uncommitted和Repeatable Read的事务隔离级别。
SQL标准定义的四个隔离级别为：
 Read Uncommitted Read Committed Repeatable Read Serializable  SQL和SQL2标准的默认事务隔离级别是Serializable。
InnoDB支持的默认事务隔离级别是Repeatable Read，但是和SQL标准不同的是，InnoDB在此隔离级别下，通过使用next-key locking算法，避免了幻读的产生，即可以完全保证事务的隔离性要求，达到了SQL标准的Serializable隔离级别。在append-only storage上，采用snapshot isolation也是避免幻读的一种实现方式。
关于事务可以洋洋洒洒写很多，这里主要聚焦InnoDB中的事务子系统的实现，详细事务的概念和事务控制技术这里略过。
2 事务子系统 #  事务子系统中的数据包括事务信息、undo log、binlog信息以及doublewrite信息。
这些信息由trx_sys page牵头，存储在各自的segment中：
   segment 存储内容 segment header     txn segment 事务信息 trx_sys page   rollback segment undo segment、history链表、undo slots rollback segment page   undo segment undo log undo segment page   doublewrite segment doublewrite数据 trx_sys_page    整体层次如下：">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="transaction" />
<meta property="og:description" content="1 事务 #  1.1 概述 #  事务是访问数据库中数据的一个程序执行单元。在一个事务中的操作，要么都做，要么不做，这是事务的目的，也是事务模型区别于文件系统的重要特征之一。
从理论上来说，事务有着极其严格的定义，必须同时满足ACID四个特性。但是数据库厂商出于各种目的，并没有严格满足事务的ACID标准。比如对于MySQL的NDB Cluster，没有满足D；对于Oracle，默认的事务隔离级别是Read Committed，不满足I。在InnoDB中，默认的事务隔离级别是Read Repeatable，完全遵循和满足事务的ACID特性。
这里要注意，D保证的是事务系统的高可靠性（High Reliability），而不是高可用性（High Availability）。对于高可用性，事务本身并不能保证，需要一些系统共同配合来完成。
1.2 分类 #  参见Jim Gray
1.3 隔离级别 #  令人惊讶的是，大部分数据库系统都没有提供真正的隔离性，最初或许是因为系统实现者并没有真正理解这些问题。如今这些问题已经弄清楚了，但是数据库的实现者在正确性和性能之间做了妥协。ISO和ANSI SQL标准制定了四种事务隔离级别的标准，但是很少有数据库厂商遵循这些标准，比如Oracle不支持Read Uncommitted和Repeatable Read的事务隔离级别。
SQL标准定义的四个隔离级别为：
 Read Uncommitted Read Committed Repeatable Read Serializable  SQL和SQL2标准的默认事务隔离级别是Serializable。
InnoDB支持的默认事务隔离级别是Repeatable Read，但是和SQL标准不同的是，InnoDB在此隔离级别下，通过使用next-key locking算法，避免了幻读的产生，即可以完全保证事务的隔离性要求，达到了SQL标准的Serializable隔离级别。在append-only storage上，采用snapshot isolation也是避免幻读的一种实现方式。
关于事务可以洋洋洒洒写很多，这里主要聚焦InnoDB中的事务子系统的实现，详细事务的概念和事务控制技术这里略过。
2 事务子系统 #  事务子系统中的数据包括事务信息、undo log、binlog信息以及doublewrite信息。
这些信息由trx_sys page牵头，存储在各自的segment中：
   segment 存储内容 segment header     txn segment 事务信息 trx_sys page   rollback segment undo segment、history链表、undo slots rollback segment page   undo segment undo log undo segment page   doublewrite segment doublewrite数据 trx_sys_page    整体层次如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ayalastrike.github.io/docs/MySQL/InnoDB/12_transaction/" /><meta property="article:section" content="docs" />



<title>transaction | Rick&#39;s Blog</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.ddfbf06e45c8c8b48d4582b40310678f3f8b64f78e5c0eaf2377a3966fc8d369.css" integrity="sha256-3fvwbkXIyLSNRYK0AxBnjz&#43;LZPeOXA6vI3ejlm/I02k=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.0779e0877f4989d99ccb68f82be59863dbccd3fe8da16f2829cd29a468861c44.js" integrity="sha256-B3ngh39Jidmcy2j4K&#43;WYY9vM0/6NoW8oKc0ppGiGHEQ=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/wukong.jpg" alt="Logo" /><span>Rick&#39;s Blog</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  <ul>
<li><a href="/docs/MySQL/"><strong>MySQL</strong></a>
<ul>
<li><a href="/docs/MySQL/Server/">Server</a>
<ul>
<li><a href="/docs/MySQL/Server/startup/">MySQL启动过程</a></li>
<li><a href="/docs/MySQL/Server/connection_handler/">MySQL的连接和请求处理</a>
<ul>
<li><a href="/docs/MySQL/Server/thd/">THD</a></li>
<li><a href="/docs/MySQL/Server/protocol/">Protocol</a>
<ul>
<li><a href="/docs/MySQL/Server/returning/">Returning（转）</a></li>
</ul>
</li>
<li><a href="/docs/MySQL/Server/net/">NET</a></li>
<li><a href="/docs/MySQL/Server/vio/">VIO</a></li>
<li><a href="/docs/MySQL/Server/8.0_net_optimize/">MySQL 8.0 对网络模块的优化（转）</a></li>
<li><a href="/docs/MySQL/Server/8.0_resource_group/">MySQL 8.0 通过Resource Group来控制线程计算资源（转）</a></li>
<li><a href="/docs/MySQL/Server/mariadb_maxscale_proxy_protocol/">MariaDB MaxScale Proxy Protocol（转）</a></li>
<li><a href="/docs/MySQL/Server/user_connection_handler/">用户建链（转）</a></li>
</ul>
</li>
<li><a href="/docs/MySQL/Server/timeout/">Timeout机制</a></li>
<li><a href="/docs/MySQL/Server/ThreadPool/">Thread Pool</a></li>
<li><a href="/docs/MySQL/Server/mdl/">MDL</a></li>
<li><a href="/docs/MySQL/Server/io_cache/">IO_CACHE</a></li>
<li><a href="/docs/MySQL/Server/memory/">内存管理</a></li>
<li><a href="/docs/MySQL/Server/signal_handler/">信号处理机制</a></li>
<li><a href="/docs/MySQL/Server/log/">日志</a></li>
<li><a href="/docs/MySQL/Server/read_only/">read_only</a></li>
<li><a href="/docs/MySQL/Server/lower_case_table_names/">lower_case_table_names</a></li>
<li><a href="/docs/MySQL/Server/invisible_index/">Invisible Index</a></li>
</ul>
</li>
<li><a href="/docs/MySQL/InnoDB/">InnoDB</a>
<ul>
<li><a href="/docs/MySQL/InnoDB/1_overview/">概览</a></li>
<li><a href="/docs/MySQL/InnoDB/2_source/">源码结构</a></li>
<li><a href="/docs/MySQL/InnoDB/3_record/">record</a></li>
<li><a href="/docs/MySQL/InnoDB/4_page/">page</a></li>
<li><a href="/docs/MySQL/InnoDB/5_storage/">storage</a></li>
<li><a href="/docs/MySQL/InnoDB/6_buffer_pool/">buffer pool</a></li>
<li><a href="/docs/MySQL/InnoDB/7_latch/">latch</a></li>
<li><a href="/docs/MySQL/InnoDB/8_b+_tree/">B+ tree</a></li>
<li><a href="/docs/MySQL/InnoDB/9_change_buffer/">change buffer</a></li>
<li><a href="/docs/MySQL/InnoDB/10_lock/">lock</a></li>
<li><a href="/docs/MySQL/InnoDB/11_redo_log/">redo log</a></li>
<li><a href="/docs/MySQL/InnoDB/12_transaction/"class=active>transaction</a></li>
</ul>
</li>
<li><a href="/docs/MySQL/Replication/">Replication</a></li>
</ul>
</li>
</ul>






  
<ul>
  
  <li>
    <a href="about" target="_blank" rel="noopener">
        About
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>transaction</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#1-事务">1 事务</a>
      <ul>
        <li><a href="#11-概述">1.1 概述</a></li>
        <li><a href="#12-分类">1.2 分类</a></li>
        <li><a href="#13-隔离级别">1.3 隔离级别</a></li>
      </ul>
    </li>
    <li><a href="#2-事务子系统">2 事务子系统</a>
      <ul>
        <li><a href="#21-trx_sys-page">2.1 trx_sys page</a></li>
        <li><a href="#22-doublewrite-segment">2.2 doublewrite segment</a></li>
      </ul>
    </li>
    <li><a href="#3-undo-log">3 undo log</a>
      <ul>
        <li><a href="#31-设计">3.1 设计</a></li>
        <li><a href="#32-物理布局">3.2 物理布局</a>
          <ul>
            <li><a href="#321-rollback-segment">3.2.1 rollback segment</a></li>
            <li><a href="#322-undo-segment">3.2.2 undo segment</a></li>
            <li><a href="#323-undo-page">3.2.3 undo page</a></li>
            <li><a href="#323-undo-log">3.2.3 undo log</a>
              <ul>
                <li><a href="#3231-insert-undo-log-record">3.2.3.1 insert undo log record</a></li>
                <li><a href="#3232-update-undo-log-record">3.2.3.2 update undo log record</a>
                  <ul>
                    <li><a href="#trx_undo_upd_exist_rec">TRX_UNDO_UPD_EXIST_REC</a></li>
                    <li><a href="#trx_undo_del_mark_rec">TRX_UNDO_DEL_MARK_REC</a></li>
                    <li><a href="#trx_undo_upd_del_rec">TRX_UNDO_UPD_DEL_REC</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#324-undo的redo">3.2.4 undo的redo</a></li>
          </ul>
        </li>
        <li><a href="#33-内存布局">3.3 内存布局</a></li>
        <li><a href="#34-undo的一生">3.4 undo的一生</a>
          <ul>
            <li><a href="#341-分配rollback-segment">3.4.1 分配rollback segment</a>
              <ul>
                <li><a href="#只读事务">只读事务</a></li>
                <li><a href="#读写事务">读写事务</a></li>
              </ul>
            </li>
            <li><a href="#342-使用rollback-segment">3.4.2 使用rollback segment</a></li>
            <li><a href="#343-写入undo-log-record">3.4.3 写入undo log record</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#4-事务">4 事务</a>
      <ul>
        <li><a href="#41-rollback">4.1 rollback</a>
          <ul>
            <li><a href="#411-rollback-pointer">4.1.1 rollback pointer</a></li>
            <li><a href="#412-回滚操作">4.1.2 回滚操作</a></li>
          </ul>
        </li>
        <li><a href="#42-commit">4.2 commit</a></li>
        <li><a href="#43-mvcc">4.3 MVCC</a>
          <ul>
            <li><a href="#431-readview">4.3.1 readview</a></li>
            <li><a href="#432-数据可见性">4.3.2 数据可见性</a></li>
            <li><a href="#433-构建版本">4.3.3 构建版本</a></li>
          </ul>
        </li>
        <li><a href="#44-purge">4.4 purge</a>
          <ul>
            <li><a href="#441-清理操作">4.4.1 清理操作</a></li>
            <li><a href="#442-purge实现">4.4.2 purge实现</a></li>
          </ul>
        </li>
        <li><a href="#45-crash-recovery">4.5 crash recovery</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="1-事务">
  1 事务
  <a class="anchor" href="#1-%e4%ba%8b%e5%8a%a1">#</a>
</h1>
<h2 id="11-概述">
  1.1 概述
  <a class="anchor" href="#11-%e6%a6%82%e8%bf%b0">#</a>
</h2>
<p>事务是访问数据库中数据的一个程序执行单元。在一个事务中的操作，要么都做，要么不做，这是事务的目的，也是事务模型区别于文件系统的重要特征之一。</p>
<p>从理论上来说，事务有着极其严格的定义，必须同时满足ACID四个特性。但是数据库厂商出于各种目的，并没有严格满足事务的ACID标准。比如对于MySQL的NDB Cluster，没有满足D；对于Oracle，默认的事务隔离级别是Read Committed，不满足I。在InnoDB中，默认的事务隔离级别是Read Repeatable，完全遵循和满足事务的ACID特性。</p>
<p>这里要注意，D保证的是事务系统的高可靠性（High Reliability），而不是高可用性（High Availability）。对于高可用性，事务本身并不能保证，需要一些系统共同配合来完成。</p>
<h2 id="12-分类">
  1.2 分类
  <a class="anchor" href="#12-%e5%88%86%e7%b1%bb">#</a>
</h2>
<p>参见Jim Gray</p>
<h2 id="13-隔离级别">
  1.3 隔离级别
  <a class="anchor" href="#13-%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab">#</a>
</h2>
<p>令人惊讶的是，大部分数据库系统都没有提供真正的隔离性，最初或许是因为系统实现者并没有真正理解这些问题。如今这些问题已经弄清楚了，但是数据库的实现者在正确性和性能之间做了妥协。ISO和ANSI SQL标准制定了四种事务隔离级别的标准，但是很少有数据库厂商遵循这些标准，比如Oracle不支持Read Uncommitted和Repeatable Read的事务隔离级别。</p>
<p>SQL标准定义的四个隔离级别为：</p>
<ul>
<li>Read Uncommitted</li>
<li>Read Committed</li>
<li>Repeatable Read</li>
<li>Serializable</li>
</ul>
<p>SQL和SQL2标准的默认事务隔离级别是Serializable。</p>
<p>InnoDB支持的默认事务隔离级别是Repeatable Read，但是和SQL标准不同的是，InnoDB在此隔离级别下，通过使用next-key locking算法，避免了幻读的产生，即可以完全保证事务的隔离性要求，达到了SQL标准的Serializable隔离级别。在append-only storage上，采用snapshot isolation也是避免幻读的一种实现方式。</p>
<p>关于事务可以洋洋洒洒写很多，这里主要聚焦InnoDB中的事务子系统的实现，详细事务的概念和事务控制技术这里略过。</p>
<h1 id="2-事务子系统">
  2 事务子系统
  <a class="anchor" href="#2-%e4%ba%8b%e5%8a%a1%e5%ad%90%e7%b3%bb%e7%bb%9f">#</a>
</h1>
<p>事务子系统中的数据包括事务信息、undo log、binlog信息以及doublewrite信息。</p>
<p>这些信息由trx_sys page牵头，存储在各自的segment中：</p>
<table>
<thead>
<tr>
<th>segment</th>
<th>存储内容</th>
<th>segment header</th>
</tr>
</thead>
<tbody>
<tr>
<td>txn segment</td>
<td>事务信息</td>
<td>trx_sys page</td>
</tr>
<tr>
<td>rollback segment</td>
<td>undo segment、history链表、undo slots</td>
<td>rollback segment page</td>
</tr>
<tr>
<td>undo segment</td>
<td>undo log</td>
<td>undo segment page</td>
</tr>
<tr>
<td>doublewrite segment</td>
<td>doublewrite数据</td>
<td>trx_sys_page</td>
</tr>
</tbody>
</table>
<p>整体层次如下：</p>
<pre><code>trx_sys page:
  → txn_segment header 
  → doublewrite_segment header
  → rollback slots (page)
  rollback segment page:
    → rollback_segment header
    → history_list
    → undo slots (page)
    undo segment page (1st page in undo segment)
      → undo log
    undo page
      → undo log
</code></pre><blockquote class="book-hint info">
  如果启用了undo表空间，其第3页会存储rollback segment array header（rollback slots），布局和现有介绍不同。
</blockquote>

<h2 id="21-trx_sys-page">
  2.1 trx_sys page
  <a class="anchor" href="#21-trx_sys-page">#</a>
</h2>
<p>事务系统段在InnoDB第一次启动时创建（trx_sysf_create），trx_sys segment header保存在系統表空間的(0, 5)位置，该页称为trx_sys page，保存以下事务信息：</p>
<ul>
<li>事务相关信息</li>
<li>rollback segment slots</li>
<li>MySQL的binlog信息</li>
<li>doublewrite segment信息</li>
</ul>
<p>trx_sys page如下图所示：</p>
<p><img src="/InnoDB_txn_trx_sys_page.png" alt="InnoDB_txn_trx_sys_page" /></p>
<p>TRX_SYS_TRX_ID_STORE保存最大事务ID，为了性能考虑，事务ID每隔256才持久化，然后在事务子系统启动时jump同样区间，跳过这个gap实现”健忘性“。</p>
<p>TRX_SYS_FSEG_HEADER保存事务系统段的segment header（space+page_no+offset）。</p>
<p>TRX_SYS_RSEGS保存回滚段信息（slot array），一共128个rollback slot（也称为回滚段对象），每个slot用8个字节存储space+page_no。</p>
<p>TRX_SYS_MYSQL_LOG_INFO保存server层的binlog信息（-1000），用以保证innoDB的日志和server层日志的一致性。</p>
<p>TRX_SYS_DOUBLEWRITE保存了doublewrite信息（-200）。</p>
<h2 id="22-doublewrite-segment">
  2.2 doublewrite segment
  <a class="anchor" href="#22-doublewrite-segment">#</a>
</h2>
<p>在buffer pool一章已经介绍，InnoDB在flush page时，为了避免partial-write，而采用doublewrite的方式进行flush，其本质上使用的是shadow page+duplex replica的方式。</p>
<p>doublewrite的segment header页保存在trx_sys page中。为了保证其在磁盘的顺序性以便顺序IO，doublewrite segment先一次性申请32个碎片页（不使用），再申请2个区，并将每个区的起始地址更新到BLOCK1、BLOCK2（buf_dblwr_create），因此总共申请了160个页（32 + 64*2），实际使用的是2个区128个页。</p>
<p>初始化代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#f00">for</span> (i = <span style="color:#f60">0</span>; i &lt; <span style="color:#f60">2</span> * TRX_SYS_DOUBLEWRITE_BLOCK_SIZE
         + FSP_EXTENT_SIZE / <span style="color:#f60">2</span>; i++) {
    new_block = fseg_alloc_free_page(
        fseg_header, prev_page_no + <span style="color:#f60">1</span>, FSP_UP, &amp;mtr);
    <span style="color:#f00">if</span> (new_block == NULL) {
        ib::error() &lt;&lt; <span style="color:#87ceeb">&#34;Cannot create doublewrite buffer: &#34;</span>
            <span style="color:#87ceeb">&#34; you must increase your tablespace size.&#34;</span>
            <span style="color:#87ceeb">&#34; Cannot continue operation.&#34;</span>;
 
        <span style="color:#f00">return</span>(false);
    }
 
    <span style="color:#0f0">/* We read the allocated pages to the buffer pool;
</span><span style="color:#0f0">    when they are written to disk in a flush, the space
</span><span style="color:#0f0">    id and page number fields are also written to the
</span><span style="color:#0f0">    pages. When we at database startup read pages
</span><span style="color:#0f0">    from the doublewrite buffer, we know that if the
</span><span style="color:#0f0">    space id and page number in them are the same as
</span><span style="color:#0f0">    the page position in the tablespace, then the page
</span><span style="color:#0f0">    has not been written to in doublewrite. */</span>
 
    ut_ad(rw_lock_get_x_lock_count(&amp;new_block-&gt;lock) == <span style="color:#f60">1</span>);
    page_no = new_block-&gt;page.id.page_no();
 
    <span style="color:#f00">if</span> (i == FSP_EXTENT_SIZE / <span style="color:#f60">2</span>) {
        ut_a(page_no == FSP_EXTENT_SIZE);
        mlog_write_ulint(doublewrite
                 + TRX_SYS_DOUBLEWRITE_BLOCK1,
                 page_no, MLOG_4BYTES, &amp;mtr);
        mlog_write_ulint(doublewrite
                 + TRX_SYS_DOUBLEWRITE_REPEAT
                 + TRX_SYS_DOUBLEWRITE_BLOCK1,
                 page_no, MLOG_4BYTES, &amp;mtr);
 
    } <span style="color:#f00">else</span> <span style="color:#ff0">if</span> (i == FSP_EXTENT_SIZE / <span style="color:#f60">2</span>
           + TRX_SYS_DOUBLEWRITE_BLOCK_SIZE) {
        ut_a(page_no == <span style="color:#f60">2</span> * FSP_EXTENT_SIZE);
        mlog_write_ulint(doublewrite
                 + TRX_SYS_DOUBLEWRITE_BLOCK2,
                 page_no, MLOG_4BYTES, &amp;mtr);
        mlog_write_ulint(doublewrite
                 + TRX_SYS_DOUBLEWRITE_REPEAT
                 + TRX_SYS_DOUBLEWRITE_BLOCK2,
                 page_no, MLOG_4BYTES, &amp;mtr);
 
    } <span style="color:#f00">else</span> <span style="color:#ff0">if</span> (i &gt; FSP_EXTENT_SIZE / <span style="color:#f60">2</span>) {
        ut_a(page_no == prev_page_no + <span style="color:#f60">1</span>);
    }
 
    <span style="color:#f00">if</span> (((i + <span style="color:#f60">1</span>) &amp; <span style="color:#f60">15</span>) == <span style="color:#f60">0</span>) {
        <span style="color:#0f0">/* rw_locks can only be recursively x-locked
</span><span style="color:#0f0">        2048 times. (on 32 bit platforms,
</span><span style="color:#0f0">        (lint) 0 - (X_LOCK_DECR * 2049)
</span><span style="color:#0f0">        is no longer a negative number, and thus
</span><span style="color:#0f0">        lock_word becomes like a shared lock).
</span><span style="color:#0f0">        For 4k page size this loop will
</span><span style="color:#0f0">        lock the fseg header too many times. Since
</span><span style="color:#0f0">        this code is not done while any other threads
</span><span style="color:#0f0">        are active, restart the MTR occasionally. */</span>
        mtr_commit(&amp;mtr);
        mtr_start(&amp;mtr);
        doublewrite = buf_dblwr_get(&amp;mtr);
        fseg_header = doublewrite
                  + TRX_SYS_DOUBLEWRITE_FSEG;
    }
 
    prev_page_no = page_no;
}
</code></pre></div><p>从这里可以看出，一共申请了64 * 2 +32个页（2 * TRX_SYS_DOUBLEWRITE_BLOCK_SIZE + FSP_EXTENT_SIZE / 2），这正如前面所分析的，doublewrite segment需要保证写入的顺序性。</p>
<h1 id="3-undo-log">
  3 undo log
  <a class="anchor" href="#3-undo-log">#</a>
</h1>
<h2 id="31-设计">
  3.1 设计
  <a class="anchor" href="#31-%e8%ae%be%e8%ae%a1">#</a>
</h2>
<p>在InnoDB中，undo log有两个用途：</p>
<ol>
<li>用来实现事务的原子性，即当事务由于主动/被动的原因而失败时，可以实现回滚，从而使数据恢复到事务开始运行时的状态</li>
<li>实现一致性非锁定读（consistent non-locking read）</li>
</ol>
<p>undo log的作用贯穿事务的整个声明周期：故障恢复（crash &amp; txn recovery）和并发控制（concurrency control）。而undo的持久性是靠redo保证的，这也是crash recovery要先做redo apply的原因之一。</p>
<p>目前绝大多数数据库都通过locking+MV的方式提供事务的并发控制，这样，只有WW阻塞，RW、WR都可以并发，这样极大提高了事务的并发度。</p>
<p>用于存储数据MV的地方称为version storage，在InnoDB中，采用delta的方式存储（因为其undo log记录的是行的diff），在PostgreSQL中，是在数据的行上实现的MV，即append-only。关于MVCC在后面一节详述。</p>
<p>InnoDB的一致性非锁定读通过多版本控制的方式（multi-versioning）来读取当前执行期间数据库中行的数据，如果需要读取的行正在执行更新操作，读取操作无需等待行上锁的释放（nonlocking），而是读取行的一个快照（read snapshot），并可以保证数据的读取一致（consistent）。</p>
<p>InnoDB的一致性非锁定读如下图所示，快照是指该行之前版本的数据，存储在undo log中。同时，因为undo log本身就会用于事务的回滚，因此快照本身是没有额外存储开销的，而且，读取快照也不需要加锁（因为不会变更数据）。</p>
<p>一致性非锁定读如下图所示：</p>
<p><img src="/InnoDB_txn_consistent_nonlocking_read.png" alt="InnoDB_txn_consistent_nonlocking_read" /></p>
<p>在redo log一章我们介绍过，redo log考虑的一个重点是recovery的时间，因此通过多种手段来做出保证，比如可以基于page来做redo log的并行recovery。而undo log和redo log却大不相同，完全不必在crash recovery阶段就完成undo（数据库运行期间就保有undo log），可以在后台异步purge，这样就可以更快的完成启动，提供服务。</p>
<p>undo log注重的是事务间的并发，以及维护MV的代价，并且与物理存储解耦。因此，undo log采用了逻辑日志的方式。</p>
<p>一个undo segment在同一时刻只属于一个事务，一个读写事务至少会持有一个undo segment，这样，当大量事务并发时，就需要存在多个undo segment为事务存储undo log，因此，会将多个undo segment组成rollback segment，并通过history链表进行GC。</p>
<p>undo log的组织有几个维度：</p>
<ul>
<li>事务维度的undo log list，用于快速rollback transaction，一个事务的所有undo log都连续存储在最多2个undo segment中</li>
<li>全局维度的已提交事务undo log list，称为history链表，用于purge GC</li>
<li>undo log的物理布局：包括存储在哪个表空间中，undo page，undo log type，undo log的组织</li>
</ul>
<p>接下来，通过从总体到局部的顺序，依次介绍rollback segment→undo segment→undo page→undo log。</p>
<h2 id="32-物理布局">
  3.2 物理布局
  <a class="anchor" href="#32-%e7%89%a9%e7%90%86%e5%b8%83%e5%b1%80">#</a>
</h2>
<p>undo log的存储由rollback segment和undo segment共同完成,，并且，这两个段的segment header都保存在各自的segment内。rollback segment中仅保存undo segment page所在页的位置，一个rollback segment一共保存1024个undo segment的信息，加上trx_sys page可以保存128个rollback segment slot，因此理论上可以支持最大128 * 1024/2个并发事务（因为同一时刻只能有一个active事务使用一个undo page，假定每个事务DML有INSERT、UPDATE、DELETE）。</p>
<p>整体关系如下图所示：</p>
<p><img src="/InnoDB_txn_undo_layout.png" alt="InnoDB_txn_undo_layout" /></p>
<h3 id="321-rollback-segment">
  3.2.1 rollback segment
  <a class="anchor" href="#321-rollback-segment">#</a>
</h3>
<p>trx_sys page描述了128个rollback segment的信息（space+page_no）。这128个rollback segment保存在rollback segment header page中，其中RSEG_0 page位于(0, 6)位置。</p>
<p>每个rollback segment header page维护了段内的history链表和1024个undo slot位置。</p>
<p>字段信息如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">TRX_RSEG_MAX_SIZE</td>
<td style="text-align:left">4</td>
<td style="text-align:left">rollback segment可以拥有的最大undo page数（ULINT_MAX）</td>
</tr>
<tr>
<td style="text-align:left">TRX_RSEG_HISTORY_SIZE</td>
<td style="text-align:left">4</td>
<td style="text-align:left">history链表中undo page的数量</td>
</tr>
<tr>
<td style="text-align:left">TRX_RSEG_HISTORY</td>
<td style="text-align:left">16</td>
<td style="text-align:left">history链表（committed undo log list）</td>
</tr>
<tr>
<td style="text-align:left">TRX_RSEG_FSEG_HEADER</td>
<td style="text-align:left">10</td>
<td style="text-align:left">rollback segment header</td>
</tr>
<tr>
<td style="text-align:left">TRX_RSEG_UNDO_SLOTS</td>
<td style="text-align:left">1024 * 4</td>
<td style="text-align:left">undo slot directory（undo segment page位置）</td>
</tr>
</tbody>
</table>
<p>总结一下，rollback segment主要存储三个信息：</p>
<ol>
<li>history链表，存储已提交事务的undo log list（按事务提交顺序逆序存放）</li>
<li>rolback segment header</li>
<li>undo slot directory</li>
</ol>
<p>在MySQL 5.7中，REG_0在系统表空间中，REG_1 ~ REG_32在临时表空间，REG_33 ~ REG_127如果配置了undo表空间（space_id固定，从1开始）则放置其内，否则在系统表空间。</p>
<h3 id="322-undo-segment">
  3.2.2 undo segment
  <a class="anchor" href="#322-undo-segment">#</a>
</h3>
<p>每个rollback segment描述了1024个undo segment page，其中每个undo segment又由一系列undo page组成，存储实际的undo log，因此undo segment可以认为是一个&quot;逻辑概念&quot;，由一组undo page构成。</p>
<p>在每个undo segment中，第一个undo page称为undo segment page，用于保存undo segment header（30字节）和相应的段元信息：</p>
<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">TRX_UNDO_STATE</td>
<td style="text-align:left">2</td>
<td style="text-align:left">UNDO segment状态（5）：TRX_UNDO_ACTIVE：段内有活跃事务的undo logTRX_UNDO_CACHE：cached for quick reuseTRX_UNDO_TO_FREE：存放的都是insert DML，可以快速freeTRX_UNDO_TO_PURGE：不能重用，交由purge线程freeTRX_UNDO_PREPARED：段内有prepared txn的undo log</td>
</tr>
<tr>
<td style="text-align:left">TRX_UNDO_LAST_LOG</td>
<td style="text-align:left">2</td>
<td style="text-align:left">最后一个undo log header offset</td>
</tr>
<tr>
<td style="text-align:left">TRX_UNDO_FSEG_HEADER</td>
<td style="text-align:left">10</td>
<td style="text-align:left">undo segment header</td>
</tr>
<tr>
<td style="text-align:left">TRX_UNDO_PAGE_LIST</td>
<td style="text-align:left">16</td>
<td style="text-align:left">undo page链表（将同一事务的segment page和normal page串在一起）</td>
</tr>
</tbody>
</table>
<h3 id="323-undo-page">
  3.2.3 undo page
  <a class="anchor" href="#323-undo-page">#</a>
</h3>
<p>undo segment中的所有page都为undo page，都有undo page header（18字节）：</p>
<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">TRX_UNDO_PAGE_TYPE</td>
<td style="text-align:left">2</td>
<td style="text-align:left">页中保存的undo log类型：TRX_UNDO_INSERT TRX_UNDO_UPDATE</td>
</tr>
<tr>
<td style="text-align:left">TRX_UNDO_PAGE_START</td>
<td style="text-align:left">2</td>
<td style="text-align:left">页中最新事务的undo log offset</td>
</tr>
<tr>
<td style="text-align:left">TRX_UNDO_PAGE_FREE</td>
<td style="text-align:left">2</td>
<td style="text-align:left">页中的空闲空间offset</td>
</tr>
<tr>
<td style="text-align:left">TRX_UNDO_PAGE_NODE</td>
<td style="text-align:left">12</td>
<td style="text-align:left">undo page链表节点（同一事务的undo page串起来）</td>
</tr>
</tbody>
</table>
<p>undo page中其余部分则存储实际的undo log。这样，一个undo page保存以下几部分信息：</p>
<ul>
<li>undo page header</li>
<li>undo segment header（段中第一页）</li>
<li>undo log&hellip;</li>
</ul>
<p>每个事务在需要记录undo log时都会申请一个或两个undo segment（insert_undo/update_undo分开），同时把事务的第一个undo page放入对应undo segment中，这个页同时也会作为undo segment header page。一个undo segment header page同一时刻只隶属于同一个活跃事务，但是一个undo header page上面存储的undo log可能包含多个已经提交的事务和一个活跃事务。</p>
<p>当活跃事务产生的undo record超过undo header page容量后，单独再为此事务分配的undo page（trx_undo_add_page）。undo page只隶属于一个事务。</p>
<p>从上面可以看出，InnoDB会复用undo page存放不同事务的undo log，是因为：</p>
<ul>
<li>OLTP事务产生的undo log相对较小</li>
<li>其他事务可能正在引用当前的undo log，事务在提交时并不能直接删除相应的undo log（insert例外）</li>
</ul>
<p>复用undo page有以下优势：</p>
<ul>
<li>可以减少undo page的分配</li>
</ul>
<p>我们计算一下，假设OLTP TPS=1000，每个事务产生200字节的undo log，如果undo page不复用，那么一分钟就要产生1000 * 60个undo page，每个undo page 16K，要分配16K * 60000 = 937M的存储空间；并且，如果purge线程每秒只能处理20个undo page，则存储用量会持续上涨。这种设计下磁盘的开销将会非常巨大。</p>
<p>因此复用undo page是合理的。undo page的复用，是指一个undo page可以存放不同事务的undo log。具体来讲，在事务提交时，首先将undo log放入history链表，然后判断当前undo page是否可以复用：</p>
<ol>
<li>undo page的可用空间是否小于3/4（TRX_UNDO_PAGE_REUSE_LIMIT ）</li>
<li>该事务只用了一个undo page</li>
</ol>
<p>如果满足则复用该undo page，并将undo segment状态设为TRX_UNDO_CACHE，之后的undo log append-only进行追加。</p>
<p>这里可以看出history链表是undo log串起来的，而undo log又分布在不同的undo page中，因此purge线程在处理history链表时会产生离散IO。</p>
<p>复用条件的判定：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#0f0">/** An update undo segment with just one page can be reused if it has
</span><span style="color:#0f0">at most this many bytes used; we must leave space at least for one new undo
</span><span style="color:#0f0">log header on the page */</span>
 
<span style="color:#e5e5e5">#define TRX_UNDO_PAGE_REUSE_LIMIT   (3 * UNIV_PAGE_SIZE / 4)
</span><span style="color:#e5e5e5"></span> 
trx_undo_set_state_at_finish() {
    ...
    <span style="color:#f00">if</span> (undo-&gt;size == <span style="color:#f60">1</span>
        &amp;&amp; mach_read_from_2(page_hdr + TRX_UNDO_PAGE_FREE)
           &lt; TRX_UNDO_PAGE_REUSE_LIMIT) {
 
        state = TRX_UNDO_CACHED;
 
     }
     ...
}
</code></pre></div><h3 id="323-undo-log">
  3.2.3 undo log
  <a class="anchor" href="#323-undo-log">#</a>
</h3>
<p>undo log是一种逻辑日志，存储的是记录修改的before image（前镜像）。因此事务的rollback意味着是将数据逻辑的恢复到原来的样子。</p>
<p>但是数据结构和page在回滚之后可能大不相同。因为，在数据库系统中，事务是并发访问的。同一页中的不同行并发，可能已经让page产生分裂/合并进而改变了B+ tree的结构，或者page的布局发生了变化。不能通过apply undo log将page回滚到该事务开始的样子，会影响其他事务在该页上的并发操作。</p>
<p>另外，redo log是基于LSN实现的，LSN具有单调递增属性，如果回滚页的物理操作，会破坏这个特性，使设计变得复杂。</p>
<p>每个undo记录由两部分内容构成：</p>
<ul>
<li>undo log header</li>
<li>undo log record</li>
</ul>
<p>undo log record又分为insert_undo/update_undo两种，insert操作产生insert undo log record，其他DML操作产生update undo log record，也存在一些特殊情况，后面另行介绍。</p>
<p>undo log的结构如下图所示：</p>
<p><img src="/InnoDB_txn_undo_log.png" alt="InnoDB_txn_undo_log" /></p>
<p>undo log header保存每个事务undo日志的通用信息。并且，因为undo页可以重用，因此回滚段的第一个undo页中可以存在多个undo log header（活跃事务的header在最后）。每个undo log header占用46个字节：</p>
<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">TRX_UNDO_TRX_ID</td>
<td style="text-align:left">8</td>
<td style="text-align:left">事务ID（事务开始的逻辑时间）</td>
</tr>
<tr>
<td style="text-align:left">TRX_UNDO_TRX_NO</td>
<td style="text-align:left">8</td>
<td style="text-align:left">事务提交顺序，也用来判断是否能purge（事物结束的逻辑时间）</td>
</tr>
<tr>
<td style="text-align:left">TRX_UNDO_DEL_MARKS</td>
<td style="text-align:left">2</td>
<td style="text-align:left">undo log中是否有DEL_MARK_REC，避免purge不必要的扫描</td>
</tr>
<tr>
<td style="text-align:left">TRX_UNDO_LOG_START</td>
<td style="text-align:left">2</td>
<td style="text-align:left">undo log header结束的offset（也是第一个undo log record的offset）</td>
</tr>
<tr>
<td style="text-align:left">TRX_UNDO_XID_EXISTS</td>
<td style="text-align:left">1</td>
<td style="text-align:left">XID</td>
</tr>
<tr>
<td style="text-align:left">TRX_UNDO_DICT_TRANS</td>
<td style="text-align:left">1</td>
<td style="text-align:left">是否为DDL事务</td>
</tr>
<tr>
<td style="text-align:left">TRX_UNDO_TABLE_ID</td>
<td style="text-align:left">8</td>
<td style="text-align:left">DDL事务修改的表</td>
</tr>
<tr>
<td style="text-align:left">TRX_UNDO_NEXT_LOG</td>
<td style="text-align:left">2</td>
<td style="text-align:left">undo log list</td>
</tr>
<tr>
<td style="text-align:left">TRX_UNDO_PREV_LOG</td>
<td style="text-align:left">2</td>
<td style="text-align:left">undo log list</td>
</tr>
<tr>
<td style="text-align:left">TRX_UNDO_HISTORY_NODE</td>
<td style="text-align:left">12</td>
<td style="text-align:left">history链表节点</td>
</tr>
</tbody>
</table>
<p>在事务每次进行DML操作时，首先分配一个undo log header（trx_undo_create），事务可能包含多个insert/update操作，但是不能存放在一个undo页中。每个类型的undo记录需要分配单独的undo段（UNDO LOG PAGE HEADER.TRX_UNDO_PAGE_TYPE）。这里的insert/update undo log record的删除时机不同：由于插入的记录对其他事务不可见，索引insert undo log record在事务提交后就可以被删除，而update/delete操作产生的update undo log record需要维护MV，只能在purge线程中随后清理。也正是因为这样，分为了两个undo segment，并且这两种undo log record分别称为：insert_undo &amp; update_undo。</p>
<p>undo log header之后存放实际的undo log record。</p>
<p>根据产生的undo log就可以将一行记录恢复到之前的版本（trx_undo_prev_version_build），这也是MVCC（或者说非锁定读）的实现过程。</p>
<p>整个undo log的存储内容如下图所示：</p>
<p><img src="/InnoDB_txn_undo_log_detail.png" alt="InnoDB_txn_undo_log_detail" /></p>
<h4 id="3231-insert-undo-log-record">
  3.2.3.1 insert undo log record
  <a class="anchor" href="#3231-insert-undo-log-record">#</a>
</h4>
<p>insert undo log record通常是指事务在INSERT操作中产生的undo日志。因为insert操作的记录只对事务本身可见，对其他事务不可见（没有历史版本），因此可以在事务提交后直接删除，不需要进行purge操作。</p>
<p>undo log record的类型为TRX_UNDO_INSERT_REC，只需为rollback做准备，而不需要考虑MVCC，因此只记录行的before image（key fields: col 1&hellip;n len+data）。</p>
<p>insert undo log的结构：</p>
<p><img src="/InnoDB_txn_undo_log_insert_undo_log_record.png" alt="InnoDB_txn_undo_log_insert_undo_log_record" /></p>
<p>rollback时根据key fields在index中定位record</p>
<h4 id="3232-update-undo-log-record">
  3.2.3.2 update undo log record
  <a class="anchor" href="#3232-update-undo-log-record">#</a>
</h4>
<p>update undo log record通常保存的是对DELETE和UPDATE操作产生的undo日志。该undo日志可能需要提供MVCC机制，因此与insert undo log record不同，其不能在事务提交时立即进行删除。当事务提交时，它会放入rollback segment的history链表的头部。然后等待purge。</p>
<p>update undo log record的结构如图所示：</p>
<p><img src="/InnoDB_txn_undo_log_update_undo_log_record.png" alt="InnoDB_txn_undo_log_update_undo_log_record" /></p>
<p>update undo log record相对于insert undo log record要复杂的多，其根据不同的事务操作，会产生不同的update undo log record。primary key是都要存储的，而上图中的最后两部分（update vector、index columns）不一定每个update undo log record都会存储。</p>
<p>update undo log record一共有3种不同的类型：</p>
<ul>
<li>TRX_UNDO_UPD_EXIST_REC：更新已经存在的记录</li>
<li>TRX_UNDO_UPD_DEL_REC  ：更新已经删除的记录</li>
<li>TRX_UNDO_DEL_MARK_REC：将记录标识为已删除</li>
</ul>
<p>除了一些&quot;事务信息&quot;，update undo log record主要存储以下3部分的信息：</p>
<ul>
<li>记录的主键值列表（primary key）</li>
<li>发生更新的列（update vector）</li>
<li>索引列</li>
</ul>
<p>主键值是一定存在的，后面2部分信息取决于操作是否产生这些修改，如果有则记录下来。比如，对于delete操作，只是将记录标记为删除，没有发生更新的列，因此没有第2部分的信息。对于update操作，则需要保存更新前记录的值（upd_t）。</p>
<p>第3部分保存的是索引列的信息。有两种情况需要保存这部分的信息：</p>
<ol>
<li>DELETE MARK操作</li>
<li>更新操作更新了索引列</li>
</ol>
<p>这样设计的目的是保存这部分信息可以在purge时删除记录所对应的secondary index。</p>
<p>当一个undo page放不下update undo log record时，会通过将已经产生的部分update undo log record删除（trx_undo_erase_page_end），并以十六进制0xFF进行填充。同时将新的undo page添加到undo segment中，并使用新申请的undo page存放update undo log record。同时，该undo page不可再进行重用。</p>
<h5 id="trx_undo_upd_exist_rec">
  TRX_UNDO_UPD_EXIST_REC
  <a class="anchor" href="#trx_undo_upd_exist_rec">#</a>
</h5>
<p>更新现有记录，需要记录update vector和index columns这两部分信息</p>
<h5 id="trx_undo_del_mark_rec">
  TRX_UNDO_DEL_MARK_REC
  <a class="anchor" href="#trx_undo_del_mark_rec">#</a>
</h5>
<p>因为要支持MVCC多版本，所以需要将DELETE的记录伪删除（更新info_bits），而真正的删除操作由purge线程完成。</p>
<p>因为没有修改任何列，因此不需要update vector的信息。一般来说，TRX_UNDO_DEL_MARK_REC类型的update undo log record占用的空间最小。</p>
<p>对于有主键值的更新操作来说，会产生TRX_UNDO_DEL_MARK_REC类型的update undo log record，同样也会产生insert undo log record。这意味着，一个SQL语句可能产生多个undo日志。</p>
<h5 id="trx_undo_upd_del_rec">
  TRX_UNDO_UPD_DEL_REC
  <a class="anchor" href="#trx_undo_upd_del_rec">#</a>
</h5>
<p>TRX_UNDO_UPD_DEL_REC表示更新已经删除的记录，但是，如果记录真的被删除，由于需要被purge，因此不可以对其进行更新操作。所以，产生该类型的update undo log应该是在同一事务内对记录进行更新操作的（DELETE+INSERT）。</p>
<pre><code>BEGIN;
DELETE FROM t where a = 1;
INSERT INTO t values (1, 'm'); 
</code></pre><p>在上面的事务中，首先删除了主键值=1的记录，随后又再次插入了主键值=1的新纪录，这时该事务会产生2个update undo log record。第一个为TRX_UNDO_DEL_MARK_REC，第二个update undo log record需要保存update vector的信息（更新了b列）。另外，由于列b是索引列，因此还需要保存索引列的信息（index columns）。</p>
<p>从这里可以发现，insert操作不一定都产生insert update undo log，也可能产生TRX_UNDO_UPD_DEL_REC类型的update undo log record。另外，在这个例子中，第二次插入的并非是主键值=1的记录，或者之后插入的记录的字节大小发生了变化，那么就不会产生TRX_UNDO_UPD_DEL_REC的undo日志，其产生的依旧是insert update undo log。</p>
<h3 id="324-undo的redo">
  3.2.4 undo的redo
  <a class="anchor" href="#324-undo%e7%9a%84redo">#</a>
</h3>
<p>在前面已经提到，undo的持久化要通过redo保证，因此undo也有对应的redo log type：</p>
<ul>
<li>MLOG_UNDO_INSERT：写入undo log record</li>
<li>MLOG_UNDO_ERASE_END：undo log跨undo page时做的抹黑（0xFF）</li>
<li>MLOG_UNDO_INIT：undo page初始化</li>
<li>MLOG_UNDO_HDR_DISCARD：废弃undo log header</li>
<li>MLOG_UNDO_HDR_REUSE：复用undo log header</li>
<li>MLOG_UNDO_HDR_CREATE：创建undo log header</li>
</ul>
<h2 id="33-内存布局">
  3.3 内存布局
  <a class="anchor" href="#33-%e5%86%85%e5%ad%98%e5%b8%83%e5%b1%80">#</a>
</h2>
<p>在事务子系统中，undo的管理非常重要，我们在上面介绍了物理布局，在内存中，也需要构建其对应的内存对象，来进行undo管理。</p>
<p>在这里，我们略过undo表空间对象，聚焦在rollback segment和undo log对象上。</p>
<p>rollback segment内存对象 trx_rseg_t</p>
<pre><code>struct trx_rseg_t {
  ulint       id;
  RsegMutex     mutex;
  ulint       space;            rollback segment page所在的位置（space+page_no）
  ulint       page_no;
  page_size_t page_size;        所在表空间的page size
  ulint       max_size;         rollback segment可以拥有的最大undo page数
  ulint       curr_size;        当前undo page数

  UT_LIST_BASE_NODE_T(trx_undo_t) update_undo_list;   活跃事务产生的update_undo链表
  UT_LIST_BASE_NODE_T(trx_undo_t) update_undo_cached; 之前事务提交后可复用的undo log list（update_undo）

  UT_LIST_BASE_NODE_T(trx_undo_t) insert_undo_list;   活跃事务产生的insert_undo链表
  UT_LIST_BASE_NODE_T(trx_undo_t) insert_undo_cached; 之前事务提交后可复用的undo log list（update_undo）

                                从trx_undo_t中提取，用于维护history链表的LWN
  ulint       last_page_no;     history链表中最后一个没有被purge的undo page no
  ulint       last_offset;      最后一个没有被purge的undo log header offset
  trx_id_t    last_trx_no;      最后一个没有被purge的事务逻辑时间
  ibool       last_del_marks;   最后一个没有被purge的undo log需要purge

  ulint       trx_ref_count;    活跃事务的引用计数，=0则rollback segment可truncate
  bool        skip_allocation;  truncate rollback segment时，trx_sys不分配该段
};
</code></pre><p>整体布局如下：</p>
<p><img src="/InnoDB_txn_undo_memory_layout.png" alt="InnoDB_txn_undo_memory_layout" /></p>
<h2 id="34-undo的一生">
  3.4 undo的一生
  <a class="anchor" href="#34-undo%e7%9a%84%e4%b8%80%e7%94%9f">#</a>
</h2>
<p>我们从整个undo的生命周期来完整系统的介绍：</p>
<ol>
<li>分配rollback segment</li>
<li>使用rollback segment</li>
<li>写入undo log</li>
<li>事务提交，事务回滚，MVCC，purge，crash recovery在事务一节介绍</li>
</ol>
<h3 id="341-分配rollback-segment">
  3.4.1 分配rollback segment
  <a class="anchor" href="#341-%e5%88%86%e9%85%8drollback-segment">#</a>
</h3>
<p>当事务&quot;产生&quot;对数据进行修改时，会相应产生undo log。也就是说，rollback segment在事务第一次&quot;需要&quot;存储undo log时才分配。</p>
<p>我们知道，事务按读写分为只读事务和读写事务，我们分别介绍这两种事务如何分配rollback segment。</p>
<h4 id="只读事务">
  只读事务
  <a class="anchor" href="#%e5%8f%aa%e8%af%bb%e4%ba%8b%e5%8a%a1">#</a>
</h4>
<p>涉及到对临时表读写，会从临时表空间分配rollback segment：REG_1 ~ REG_32。（trx_assign_rseg）</p>
<h4 id="读写事务">
  读写事务
  <a class="anchor" href="#%e8%af%bb%e5%86%99%e4%ba%8b%e5%8a%a1">#</a>
</h4>
<p>事务默认都是只读事务，只有当随后判定为读写模式时，才切成读写事务，并分配TrxID和rollback segment（trx_set_rw_mode）。</p>
<p>分配流程如下：</p>
<ol>
<li>采用round-robin的轮询方式来分配，如果rollback segment被标记为skip_allocation，则跳过</li>
<li>分配后，rseg-&gt;trx_ref_count++</li>
<li>临时表rseg挂到trx-&gt;rsegs-&gt;m_noredo，普通rseg挂到trx-&gt;rsegs-&gt;m_redo</li>
</ol>
<p>代码调用链如下：</p>
<pre><code>trx_assign_rseg
  trx_assign_rseg_low(srv_rollback_segments, srv_undo_tablespaces, TRX_RSEG_TYPE_NOREDO)
    rseg = get_next_noredo_rseg(srv_tmp_undo_logs + 1);

trx_set_rw_mode   设置为读写事务
  trx_assign_rseg_low(srv_rollback_segments, srv_undo_tablespaces, TRX_RSEG_TYPE_REDO)
    rseg = get_next_redo_rseg(max_undo_logs, n_tablespaces);
</code></pre><h3 id="342-使用rollback-segment">
  3.4.2 使用rollback segment
  <a class="anchor" href="#342-%e4%bd%bf%e7%94%a8rollback-segment">#</a>
</h3>
<p>流程如下（trx_undo_report_row_operation）：</p>
<ol>
<li>当前变更如果是临时表（dict_table_is_temporary），则使用临时表rseg（trx-&gt;rsegs.m_noredo）；否则使用普通rseg（trx-&gt;rsegs.m_redo）</li>
<li>判断变更类型
<ol>
<li>insert_undo，单独分配undo slot</li>
<li>update_undo，单独分配undo slot</li>
</ol>
</li>
</ol>
<p>分配undo slot（undo segment）（trx_undo_assign_undo）</p>
<ol>
<li>首先复用rseg上的cached undo list，
<ol>
<li>insert_undo：修改seg_hdr（改为active）和page_hdr（start, free），预留XID位置</li>
<li>update_undo：在undo segment page创建undo log header，预留XID位置</li>
</ol>
</li>
<li>初始化trx_undo（设为active）</li>
<li>如果没有cached undo list，从rollback segment分配一个undo slot，并初始化undo page（如果1024分配完了，返回DB_TOO_MANY_CONCURRENT_TRXS错误）</li>
<li>将trx_undo加入active undo list</li>
<li>如果是DDL事务，还要记录元信息（TRX_UNDO_DICT_TRANS=true &amp;&amp; table_id）</li>
</ol>
<blockquote class="book-hint danger">
  这里留给读者一个问题：在#1中对于update_undo，为什么要在undo segment page中创建undo log header
</blockquote>

<h3 id="343-写入undo-log-record">
  3.4.3 写入undo log record
  <a class="anchor" href="#343-%e5%86%99%e5%85%a5undo-log-record">#</a>
</h3>
<p>写入undo log record流程如下（trx_undo_report_row_operation）：</p>
<ol>
<li>选择undo page（undo-&gt;last_page_no）</li>
<li>按照insert_undo/update_undo进行插入记录</li>
<li>如果写入过程中空间不足，则将已写部分涂黑0xFF（trx_undo_erase_page_end），然后申请新的undo page重新写入</li>
<li>构建rollback pointer，并更新到clustered index record中</li>
</ol>
<h1 id="4-事务">
  4 事务
  <a class="anchor" href="#4-%e4%ba%8b%e5%8a%a1">#</a>
</h1>
<p>大多数数据库采用STEAL+NO-FORCE的方式，在事务推进国产中，不断写入undo log，然后在事务提交时，保证redo log持久化到磁盘。这样，当发生被动故障时，就可以通过crash recovery将数据恢复到一致的状态。</p>
<h2 id="41-rollback">
  4.1 rollback
  <a class="anchor" href="#41-rollback">#</a>
</h2>
<h3 id="411-rollback-pointer">
  4.1.1 rollback pointer
  <a class="anchor" href="#411-rollback-pointer">#</a>
</h3>
<p>在record一章我们介绍过，行记录通过roll_ptr将行的历史变化串联起来，实现MV。</p>
<p>在MVCC中，通过当前行不断apply undo log record，来构造出之前的版本。</p>
<p>rollback pointer指针占用7个字节：undo segment no需要1个字节，且最高位保存undo log type；undo page需要4个字节；undo log需要2个字节。因此可以通过rseg_id+page_no+offset构造出rollback pointer（trx_undo_build_roll_ptr），也可反解（trx_undo_decode_roll_ptr）。</p>
<p><img src="/InnoDB_txn_rollback_pointer.png" alt="InnoDB_txn_rollback_pointer" /></p>
<p><img src="/InnoDB_txn_rollback_chain.png" alt="InnoDB_txn_rollback_chain" /></p>
<h3 id="412-回滚操作">
  4.1.2 回滚操作
  <a class="anchor" href="#412-%e5%9b%9e%e6%bb%9a%e6%93%8d%e4%bd%9c">#</a>
</h3>
<p>根据回滚操作的发起者来分类，可以分为用户态的回滚和内核态的回滚。</p>
<p>用户态的回滚指的是用户通过rollback命令发起。</p>
<p>内核态的回滚指的是InnoDB内部发起的回滚，一共有两种：</p>
<ul>
<li>仅回滚事务最近的一个语句：比如违反唯一性约束，那么仅回滚最近的一个SQL语句，事务的状态依然是活跃的。</li>
<li>回滚整个事务，和用户态的回滚一样：比如发生死锁时回滚victim的事务。</li>
</ul>
<p>InnoDB内部定义了三种回滚类型</p>
<ul>
<li>TRX_SIG_TOTAL_ROLLBACK：回滚整个事务</li>
<li>TRX_SIG_ROLLBACK_TO_SAVEPT：回滚到最近一个保存点（InnoDB支持保存点的事务，并且，保存点事务也是基于undo实现的（trx_t::undo_no，每次事务写入undo++））</li>
<li>TRX_SIG_ERROR_OCCURRED：当错误发生时进行回滚（没有找到触发的事件）</li>
</ul>
<p>在进行回滚操作时，InnoDB主要做两件事情：</p>
<ol>
<li>根据trx_id找到undo log record（从undo segment page中根据当前事务的trx_id找到对应的undo log header）</li>
<li>根据undo log record顺序找到最后一个undo log record，逆序回滚记录</li>
</ol>
<p>若回滚操作进行的是TRX_SIG_TOTAL_ROLLBACK，即重复上述两个操作直到事务中所有的undo log record都已经被回滚。回滚时根据undo log record进行逆序操作（trx_roll_pop_top_rec_of_trx）。当回滚整个事务完成之后，undo log record的空间被释放，可以供之后的事务存放undo log，但需要特别注意的是：回滚后undo log header所占用的空间是不被释放的，但是这并不影响purge。</p>
<p>当取得undo log record后，需要根据不同类型的undo log record进行处理。</p>
<ul>
<li>insert undo log record：进行逆操作DELETE即可，首先删除secondary index中的记录，在删除clustered index中的记录（调用btr_cur_optimistic_delete或btr_cur_optimistic_optimistic，而不是像redo log recovery哪有直接对physical page进行直接操作）。DELETE操作是真正的删除操作，而不是DELETE MARK的伪删除。这是因为事务并没有提交，所以记录对所有其他事务是不可见的，因此可以立即删除，不需要等purge线程来清理。此外，回滚是一个逻辑操作，这和redo log不同。</li>
<li>update undo log record：三种类型，回滚因人而异。但一样是是逻辑操作，处理顺序也是secondary index→clustered index（row_undo_mod）
<ul>
<li>从update_undo中解析出update vector回退seconary index：去除delete mark标记，或者用update vector中的diff信息修改成之前的值（row_undo_mod_del_unmark_sec_and_undo_update）</li>
<li>同样用update vector中的diff信息修改clustered index（row_undo_mod_clust）</li>
</ul>
</li>
</ul>
<p>总结一下，逆向操作可以分为以下几种：</p>
<ul>
<li>delete mark = 1改为0</li>
<li>in-place更新直接改成旧值</li>
<li>对于插入操作，依次删除seoncdary index和clustered index
<ul>
<li>row_undo_ins_remove_sec_rec</li>
<li>row_undo_ins_remove_clust_rec</li>
</ul>
</li>
</ul>
<p>当回滚处理完最后一个undo log record后，释放之前undo log record所占用的空间（trx_undo_truncate_end），但是并不回收undo log header。</p>
<p>回滚同样需要提交，因为与正常提交一样，需要释放事务所持有的资源：undo segment、lock、read view，并flush redo log buffer。</p>
<h2 id="42-commit">
  4.2 commit
  <a class="anchor" href="#42-commit">#</a>
</h2>
<p>事务提交分为两种：隐式提交和显式提交。</p>
<p>当执行DDL，或者采用事务控制语句（BEGIN，START TRANSACTION时），为隐式提交。</p>
<p>显式提交，发送COMMIT。</p>
<p>另外，MySQL因为架构分为server层和engine层，为了保证两层日志的一致性，</p>
<p>事务提交时，为了和server层的binlog做XA，InnoDB的commit分为2个阶段（2PC）：</p>
<ul>
<li>prepare：
<ul>
<li>将事务状态从active-&gt;prepared，即将所有undo slot中的undo segment page的seg_hdr.TRX_UNDO_STATE=TRX_UNDO_PREPARED（trx_undo_set_state_at_prepare）</li>
<li>填充XID（执行事务的第一条SQL时，就会注册XA，并根据thd-&gt;query_id分配XID）（trans_register_ha）</li>
</ul>
</li>
<li>commit：
<ul>
<li>将所有undo slot设为完成态（CACHED/TO_FREE/TO_PURGE）
<ul>
<li>如果undo segment iff 1 undo page &amp;&amp; 使用量小于3/4，复用该undo segment（将该undo segment状态设为TRX_UNDO_CACHE）</li>
<li>含有insert undo log record，事务提交后快速free掉（将该undo segment状态设为TRX_UNDO_TO_FREE）</li>
<li>含有update undo log record，undo segment交由purge free（将该undo segment状态设为TRX_UNDO_TO_PURGE）</li>
</ul>
</li>
<li>将rseg加入purge队列（purge_sys-&gt;purge_queue）</li>
<li>更新rseg-&gt;last_*四元组</li>
<li>串到cached undo list（insert_undo知道事务释放完全部资源才free）</li>
<li>rseg-&gt;trx_ref_count&ndash;</li>
<li>如果开启了binlog（trx-&gt;mysql_log_file_name != NULL &amp;&amp; trx-&gt;mysql_log_file_name[0] != &lsquo;\0&rsquo;），在trx_sys page写入binlog信息</li>
<li>清理read view对象</li>
<li>flush redo log buffer（WAL）</li>
<li>将trx从事务列表中删除</li>
</ul>
</li>
</ul>
<p>redo log中并没有一个&quot;特殊&quot;的redo log record表示事务结束：事务结束的标志是事务的undo log放入rollback segment的history链表。这个操作将redo log写入mtr中，mtr.commit后在事务提交时flush redo log buffer完成。</p>
<p>调用链如下：</p>
<pre><code>trx_commit_low
  trx_write_serialisation_history
    trx_undo_set_state_at_finish
</code></pre><blockquote class="book-hint danger">
  <p>这里留给读者2个思考：</p>
<p>为什么不直接设置一个特殊的redo log标识事务结束？</p>
<p>为什么可以事务结束的标识放到history链表中？</p>

</blockquote>

<h2 id="43-mvcc">
  4.3 MVCC
  <a class="anchor" href="#43-mvcc">#</a>
</h2>
<p>从前面的undo chain图上可以很直观的看到，undo记录包含了行数据的历史版本，因此，MVCC可以：</p>
<ul>
<li>根据rollback pointer可以回溯undo log，进而可以构建出那个版本的数据</li>
<li>根据trx_id判断可见性</li>
</ul>
<p>简单来说就是对于RC及以上隔离级别（RU直接读取当前行记录），当前事务只能看到其他已经提交的事务的数据，不能看到active事务修改中的数据。</p>
<p>因为trx_id是单调递增的，因此，我们可以在一个线性序列上依托于trx_id构建可见性，因此：</p>
<ul>
<li>trx_id：事务开始的逻辑时间，在事务开始时分配</li>
<li>trx_no：事务结束的逻辑时间，在事务提交commit阶段分配，这个用于构建purge的可见性</li>
<li>trx_sys-&gt;rw_trx_ids：当前active的读写事务列表，开启读写事务时加入，读写事务提交时移除</li>
</ul>
<p>以及基于以上构建readview</p>
<p>读写异常是因为本事务的R和其他事务的R+W有交集，MVCC也是本着这个本质来解决问题的，解决问题的核心是定序。</p>
<p>只读事务的trx_id始终为0（不分配），读写事务分配trx_id，另外，readview都分配，</p>
<h3 id="431-readview">
  4.3.1 readview
  <a class="anchor" href="#431-readview">#</a>
</h3>
<p>readview的生命周期：</p>
<ol>
<li>分配：在显式start transaction with consistent snapshot或RR时，事务开始就分配（在事务期间不变，保证可见性不变）；其他情况读取数据时才分配（trx_assign_read_view）</li>
<li>回收：事务commit后，清理资源阶段进行回收（view_close）</li>
</ol>
<p>全局的readview通过一个readview链表维护（trx_sys-&gt;mvcc-&gt;readview-&gt;m_views），在头部插入新的readview，因此，链表中最后一个还没有close的readview就是oldest readview（这是purge的基础）。</p>
<p>readview由以下几部分构成：</p>
<ul>
<li>m_low_limit_id：高水位，分配时取trx_sys::max_trx_id，也就是取当前还没有被分配的事务ID</li>
<li>m_up_limit_id：低水位，如果m_ids不为空，取其最小值，否则取trx_sys::max_trx_id</li>
<li>m_ids：当前活跃事务列表（不包括自己）</li>
<li>m_creator_trx_id：本事务（自己）</li>
</ul>
<p>本质就是读取时获得一个快照版本，active的，自己的可见，别人的不可见；（高水位）未来的不可见，（低水位）过去的可见。</p>
<p>活跃事务：</p>
<ol>
<li>trx_id &gt; read_view::m_low_limit_id</li>
<li>read_view::m_up_limit_id &lt; trx_id &lt; read_view::m_low_limit_id，并且 trx_id 属于 trx_t::read_view::m_ids</li>
</ol>
<p>已提交事务：</p>
<ol>
<li>trx id &lt; read_view::m_up_limit_id</li>
<li>read_view::m_up_limit_id &lt; trx id &lt; read_view::m_low_limit_id，并且 trx id 不属于 trx_t::read_view::m_ids</li>
</ol>
<h3 id="432-数据可见性">
  4.3.2 数据可见性
  <a class="anchor" href="#432-%e6%95%b0%e6%8d%ae%e5%8f%af%e8%a7%81%e6%80%a7">#</a>
</h3>
<p>事务为T，trx_id为记录R中的DATA_TRX_ID：</p>
<ul>
<li>trx_id &gt; 高水位，T 不可见 R</li>
<li>trx_id &lt; 低水位，T 可见 R</li>
<li>在高低之间，如果是自己，T可见R，否则不可见</li>
</ul>
<p>比如下图示例：</p>
<p><img src="/InnoDB_txn_MVCC.png" alt="InnoDB_txn_MVCC" /></p>
<p>这里要理解insert_undo为什么事务提交后可以抛弃，readview的遍历方式。</p>
<h3 id="433-构建版本">
  4.3.3 构建版本
  <a class="anchor" href="#433-%e6%9e%84%e5%bb%ba%e7%89%88%e6%9c%ac">#</a>
</h3>
<p>因为在clustered index的行上存储了trx_id和roll_ptr，因此可以通过trx_id判断可见性，如果不可见，则通过roll_ptr继续向前构建，直至可见或者达到尾部。（row_vers_build_for_consistent_read）。</p>
<p>这也是线性系统的一种体现。</p>
<blockquote class="book-hint info">
  <p>因为构建MV需要持有page latch，如果active事务很多，则undo chain可能会很长，要注意latch的持有时长。</p>
<p>undo log record如果是insert_undo，不用查看undo，因为未提取事务的新插入记录，对其他事务一定不可见。</p>
<p>对于secondary index记录，如果page上的最大事务ID（PAGE_MAX_TRX_ID）对当前事务是可见的，也无需构建MV，否则还要去走clustered index record构建。</p>

</blockquote>

<h2 id="44-purge">
  4.4 purge
  <a class="anchor" href="#44-purge">#</a>
</h2>
<p>purge操作负责清理已提交的不再被使用的数据，包括记录和日志。</p>
<p>清理这些数据依托于undo log，更进一步，依托于构建在提交序上的点位（trx_no），再结合SQL graph，展开实际的清理。</p>
<h3 id="441-清理操作">
  4.4.1 清理操作
  <a class="anchor" href="#441-%e6%b8%85%e7%90%86%e6%93%8d%e4%bd%9c">#</a>
</h3>
<p>purge清理属于事后打扫，这一方面保证forward fast，另一方面为了MVCC的GC，因此，清理工作包括：</p>
<ul>
<li>清理记录：清理delete mark的行记录或者secondary index record（update undo log record中标记修改了secondary index相应值）</li>
<li>清理undo log：清理undo log，如果undo page中的所有undo log都清理后，则删除对应的undo segment。在清理undo log时，需要判断当前是否有其他事务正在进行MVCC。</li>
</ul>
<p>undo有几个序：</p>
<ol>
<li>undo申请序：事务在进行DML操作时申请undo page用于存放undo log，在一个undo segment中一个事务会占用1&hellip;n个undo page，但在undo segment是无序的。</li>
<li>undo使用序：undo page可以复用，存储不同事务的undo log，在page维度的存储序是committed-committed-active。</li>
<li>提交序：history链表标识已提交事务序，这可以关联到事务中的undo log序，这个undo log序分布在同一个undo segment中的不同undo page中，通过undo log header串联，history和各个undo log header串联起来已提交序。</li>
</ol>
<p>总结一下：</p>
<ul>
<li>undo segment整体是无序的</li>
<li>undo page按事务状态排序</li>
<li>提交序离散分布在rollback segment中的各个undo page中</li>
</ul>
<p>purge的执行序列通过构建SQL execution graph来实现。</p>
<p>这里注意：</p>
<ul>
<li>事务的提交序和执行序不一样，因此在purge undo和purge记录时有依赖关系，需要构建graph</li>
</ul>
<p>并且，在进行purge操作时，会产生大量的随机读，这可能会产生性能问题。另外，如果出现了长事务正在使用mvcc（比如最新的active事务），则会导致history链表最头部的已提交事务的undo log的回收无法进行。</p>
<h3 id="442-purge实现">
  4.4.2 purge实现
  <a class="anchor" href="#442-purge%e5%ae%9e%e7%8e%b0">#</a>
</h3>
<p>purge_sys全局对象（trx_purge_t）保存当前purge的位置和信息。</p>
<p>purge流程如下：</p>
<ol>
<li>
<p>通过purge point确认可见性（purge_sys::view）</p>
<p>通过clone oldest active readview（clone_oldest_view），来保证purge point之前的事务变更都是可以清理的</p>
<p>具体解释一下，在事务子系统中，committing事务保存在serialisation_list中，并按照提交序排列（trx_no）。在事务prepare时加入，事务commit时移除</p>
<p>并且，在readview中还会维护一个serialisation_list LWN（read_view::m_low_limit_no：取自serialisation_list trx_no最小值），其含义是如果其他事务的trx_no比其小，一定已提交。
这样，一个事务的readview的LWN就确定了，那么全局的LWN即为所有readview的最小点（trx_no，直接按提交序倒排第一个即是），这个点即为purge point</p>
</li>
<li>
<p>从各个rollback segment中的history链表中依次（从后）读取最多300个undo log（trx_purge_fetch_next_rec递归），分配到各个purge线程的工作队列中（vector thr-&gt;child-&gt;undo_recs）</p>
<p>这些history链表已经在事务提交时加入puge_sys::purge_queue中了，即可以将该queue理解为以trx_no为key的优先级队列</p>
<p>因此，purge_sys::view和所有histroy链表已经存在交集。</p>
<p>因此这里可以理解成两层关系，purge_queue维护了提交序，负责推进purge，其来源来自于rollback segment的history链表，。</p>
</li>
<li>
<p>实际purge（细节见下）：分为undo purge和undo truncate</p>
</li>
<li>
<p>清理history list（每128）</p>
<p>insert_undo的undo segment事务提交后就释放，update undo在做完history后，也到了释放时机。但因为undo page的复用，一个undo segment是离散分布的，所以需要全局推进。因此，每做完128次purge后，进行一次purge history链表。</p>
<p>从history链表中遍历释放undo segment，因为history是按照提交序排列的，所以遇到一个还未purge的undo log（trx_no比当前purge point大）则停止。</p>
</li>
</ol>
<p>第三步的purge函数调用栈如下：</p>
<pre><code>row_purge_step                        // purge single undo log record(全部清理完成返回node，即purge线程)
  row_purge                           // fetch &amp; purge (300),从purge_queue取第一个rseg，从history链表中取最老的还还没有purge的undo log header，一次读取该事务的undo log record，依次往复，直到300或没有
    row_purge_parse_undo_rec          // parse update_undo
      row_purge_record                // undo记录（secondary-&gt;clustered）
        row_purge_del_mark               1. delete mark 1-&gt;0 物理删除所有涉及的记录 undo purge
        row_purge_upd_exist_or_extern    2. clustered index in-place update, 可能更新secondary index（delete+insert），清理, undo truncate
</code></pre><p>当一个undo segment段中的最后一个undo log被清理完毕后，则将该undo segment删除（trx_purge_free_segment）。这里有两个细节需要特别注意：</p>
<ol>
<li>
<p>如果一个undo segment包含多个undo page时，当进行undo slot的回收时，首先删除最后一个undo页，并进行mtr_commit。</p>
<p>如果在这时，即undo segment的最后一个undo log所在的最后一个undo page从段中被删除时，数据库crash，那么重启后，重新进行purge时，会导致最后一个undo log的最后一部分undo log record可能会出现不一致的问题（因为回收的undo page可能已经分配给其他段使用），这时，再进行purge操作会导致错误发生。因此，InnoDB在设计时对每个undo log header，设置了一个TRX_UNDO_DEL_MARKS标记。当最后一个undo log删除时，首先将其置为true，那么crash recovery而重新purge时，由于该变量已置为true，所以不需要继续进行purge操作</p>
</li>
<li>
<p>rollback segment的history链表的更新与undo segment的删除需要在一个mtr中。否则，当数据库宕机时，可能发生rollback segment的history链表已经将undo log删除，而undo segment还存在的情况。在这种情况下，undo segment将没有机会被删除，却需要一直占用存储空间。</p>
</li>
</ol>
<p>purge_is_running用于保护DROP TABLE的操作，当进行purge undo日志时，需要持有该对象的x-latch；当需要进行DROP TABLE时，需要持有该对象的s-latch，以此保证当进行purge操作时，表不会被删除。</p>
<p>latch用于保证删除undo日志的正确性，保证删除时没有其他事务正在引用该undo日志。当开启purge操作时，首先需要持有该x-latch，然后通过read_view_oldest_copy_or_open_new判断哪些undo日志可以被清理（注意：purge是一个特殊的事务，事务类型为TRX_PURGE，其他都是用户事务）。当用户事务需要通过undo日志进行多版本并发控制（一致性非锁定读）时，需要首先获得该对象的s-latch。</p>
<h2 id="45-crash-recovery">
  4.5 crash recovery
  <a class="anchor" href="#45-crash-recovery">#</a>
</h2>
<p>crash recovery的恢复分为两个阶段：</p>
<ol>
<li>
<p>forward，恢复到内存态，即将redo log从checkpoint到最新，进行apply，将磁盘上的数据恢复到crash时的内存态，其中也包括undo log。</p>
</li>
<li>
<p>backward：因为buffer pool的STEAL+NO-FORCE，需要将active STEAL的数据rollback掉，即找出活跃事务，将其rollback，也称为failure atomic。</p>
<p>具体来讲，遍历所有rollback segment，读取其undo segment中的undo segment page中TRX_UNDO_STATE，可以得知其事务状态（还记得前面说过的吗，一个undo segment只会最多有一个active transaction），如果为活跃事务，则需要遍历该事务的undo来rollback，以及构建出事务子系统的内存布局：trx_sys，trx_t，trx_rseg_t和trx_undo_t</p>
</li>
</ol>
<p>这里还需要考虑XA事务，即保证server层的binlog和InnoDB数据的一致，通过2PC我们可以知道，只要过了commit point，就可以forward。这样，我们就可以通过判断binlog是否已经记录（扫描最后一个binlog文件，拿binlog的XID和InnoDB的XID做比对，如果binlog有，则提交InnoDB事务，否则回滚InnoDB事务）。</p>
<p>总结一下，数据库系统整体的恢复节奏如下：</p>
<ol>
<li>redo recovery</li>
<li>数据字典子系统初始化</li>
<li>事务子系统初始化&amp;重建</li>
<li>XA事务恢复</li>
</ol>
<p>redo recovery详细的函数调用栈如下：</p>
<pre><code>innobase_start_or_create_for_mysql
	recv_sys_var_init();
	recv_sys_create();
		malloc recv_sys
		create mutex/writer_mutex
	recv_sys_init(buf_pool_get_curr_size());
		创建一个MEM_HEAP_FOR_RECV_SYS的heap 用于存放 log records和file
		create flush_start/flush_end event
		recovery时在buffer pool instance中预留好的frame数量 512 recv_n_pool_free_frames
		malloc recv_sys-&gt;buf (parser buffer) 2M
		malloc recv_sys-&gt;addr_hash 大小为 buffer_pool_size/512
		recv_sys-&gt;last_block_buf_start = 2 * 512
		malloc recv_sys-&gt;dblwr
	recv_recovery_from_checkpoint_start(flushed_lsn);
	recv_sys-&gt;dblwr.pages.clear();
	recv_apply_hashed_log_recs(TRUE);						从log records hash table应用到page
		在buffer pool中， recv_recover_page -&gt; recv_parse_or_apply_log_rec_body
		不在内存中，recv_read_in_area
			buf_read_recv_pages
			buf_read_page_low
				buf_page_io_complete
	recv_recovery_from_checkpoint_finish();

recv_recovery_from_checkpoint_start
	创建buffer pool instances中的flush list（红黑树）buf_flush_init_flush_rbt
	在redo log file group中查找最新的CP的file和其CP位置 recv_find_max_checkpoint
	从file的CP位置读取CP信息放入 log_sys-&gt;checkpoint_buf
	从CP信息中解析出 checkpoint_lsn checkpoint_no
	contiguous_lsn = checkpoint_lsn
	从contiguous_lsn开始扫描，把redo log放入hash table recv_group_scan_log_recs
	...

	recv_synchronize_groups();	更新group-&gt;lsn, lsn_offset，做checkpoint
	更新log_sys-&gt;点位

recv_group_scan_log_recs
	end_lsn = contiguous_lsn = 512对齐后的checkpoint_lsn
	do {
		start_lsn = end_lsn
		end_lsn += 4 * 16K = 128 log block
		log_group_read_log_seg(log_sys-&gt;buf, group, start_lsn, end_lsn);	从redo log file中将start_lsn - end_lsn的数据读入log_sys-&gt;buf
	} while (!recv_scan_log_recs(
			 available_mem,				page_size * (buffer pool总page-512*instance)
			 &amp;store_to_hash,			STORE_YES / STORE_IF_EXISTS redo log record是否需要存在hash table里
			 log_sys-&gt;buf,
			 RECV_SCAN_SIZE,			128 log block
			 checkpoint_lsn,
			 start_lsn, contiguous_lsn, &amp;group-&gt;scanned_lsn)

recv_scan_log_recs									解析128个log block Scans log from a buffer and stores new log data to the parsing buffer.
	recv_sys_add_to_parsing_buf						处理每个log block，一直处理完128 log block，拷贝到recv_sys-&gt;buf Adds data from a new log block to the parsing buffer of recv_sys
	recv_parse_log_recs								处理recv_sys-&gt;buf中的mtr record
		single page/
		recv_parse_log_rec							parse a single log record
		recv_add_to_hash_table						将mtr record放入hash table，元素为recv_t，规则为space_id,page_no
		multiple page
		loop in recv_parse_log_rec （多次）
		loop in recv_parse_log_rec + recv_add_to_hash_table
			recv_parse_or_apply_log_rec_body		在recv_parse_log_rec中只分析

		从log records hash table应用到page
	recv_sys_justify_left_parsing_buf
</code></pre></article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#1-事务">1 事务</a>
      <ul>
        <li><a href="#11-概述">1.1 概述</a></li>
        <li><a href="#12-分类">1.2 分类</a></li>
        <li><a href="#13-隔离级别">1.3 隔离级别</a></li>
      </ul>
    </li>
    <li><a href="#2-事务子系统">2 事务子系统</a>
      <ul>
        <li><a href="#21-trx_sys-page">2.1 trx_sys page</a></li>
        <li><a href="#22-doublewrite-segment">2.2 doublewrite segment</a></li>
      </ul>
    </li>
    <li><a href="#3-undo-log">3 undo log</a>
      <ul>
        <li><a href="#31-设计">3.1 设计</a></li>
        <li><a href="#32-物理布局">3.2 物理布局</a>
          <ul>
            <li><a href="#321-rollback-segment">3.2.1 rollback segment</a></li>
            <li><a href="#322-undo-segment">3.2.2 undo segment</a></li>
            <li><a href="#323-undo-page">3.2.3 undo page</a></li>
            <li><a href="#323-undo-log">3.2.3 undo log</a>
              <ul>
                <li><a href="#3231-insert-undo-log-record">3.2.3.1 insert undo log record</a></li>
                <li><a href="#3232-update-undo-log-record">3.2.3.2 update undo log record</a>
                  <ul>
                    <li><a href="#trx_undo_upd_exist_rec">TRX_UNDO_UPD_EXIST_REC</a></li>
                    <li><a href="#trx_undo_del_mark_rec">TRX_UNDO_DEL_MARK_REC</a></li>
                    <li><a href="#trx_undo_upd_del_rec">TRX_UNDO_UPD_DEL_REC</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#324-undo的redo">3.2.4 undo的redo</a></li>
          </ul>
        </li>
        <li><a href="#33-内存布局">3.3 内存布局</a></li>
        <li><a href="#34-undo的一生">3.4 undo的一生</a>
          <ul>
            <li><a href="#341-分配rollback-segment">3.4.1 分配rollback segment</a>
              <ul>
                <li><a href="#只读事务">只读事务</a></li>
                <li><a href="#读写事务">读写事务</a></li>
              </ul>
            </li>
            <li><a href="#342-使用rollback-segment">3.4.2 使用rollback segment</a></li>
            <li><a href="#343-写入undo-log-record">3.4.3 写入undo log record</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#4-事务">4 事务</a>
      <ul>
        <li><a href="#41-rollback">4.1 rollback</a>
          <ul>
            <li><a href="#411-rollback-pointer">4.1.1 rollback pointer</a></li>
            <li><a href="#412-回滚操作">4.1.2 回滚操作</a></li>
          </ul>
        </li>
        <li><a href="#42-commit">4.2 commit</a></li>
        <li><a href="#43-mvcc">4.3 MVCC</a>
          <ul>
            <li><a href="#431-readview">4.3.1 readview</a></li>
            <li><a href="#432-数据可见性">4.3.2 数据可见性</a></li>
            <li><a href="#433-构建版本">4.3.3 构建版本</a></li>
          </ul>
        </li>
        <li><a href="#44-purge">4.4 purge</a>
          <ul>
            <li><a href="#441-清理操作">4.4.1 清理操作</a></li>
            <li><a href="#442-purge实现">4.4.2 purge实现</a></li>
          </ul>
        </li>
        <li><a href="#45-crash-recovery">4.5 crash recovery</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












