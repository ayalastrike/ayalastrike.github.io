[{"id":0,"href":"/about/","title":"About","section":"Rick's Blog","content":"Email: tianjiawei@gmail.com\n"},{"id":1,"href":"/docs/MySQL/InnoDB/1_overview/","title":"1 Overview","section":"Inno Db","content":"Heikki Tuuri是InnoDB存储引擎的创始人，1964年生于芬兰赫尔辛基。与著名Linux操作系统的创始人Linus一样毕业于芬兰赫尔辛基大学。从入学时间来看，Heikki Tuuri还是Linus的学长。在1990年取得赫尔辛基大学的数理逻辑博士学位后。\n所以，innodb的代码大部分都是Created mm/dd/YYYY Heikki Tuuri。\nMySQL大事时间表：\n 1995：Heikki Tuuri成立Innobase Oy公司并担任CEO。同年，由David Axmark、Allan Larsson和Michael Monty Widenius在瑞典创办MySQL AB公司。 2001：Innobase公司开始与MySQL AB公司进行合作并开源InnoDB存储引擎的代码。 2005：Oracle公司收购了Innobase公司。 2008：Sun收购MySQL AB公司。 2009：2009年4月20日，Sun 公司董事会通过决议，同意以每股9.5美元的价格将公司出售给Oracle。  "},{"id":2,"href":"/docs/MySQL/InnoDB/2_source/","title":"2 Source","section":"Inno Db","content":"typora-root-url: ../../../../static\n在MySQL源代码中，每个模块都有自己单独的目录存放，里面按照模块名0子模块名.cc来组织。所有头文件都放在include目录下，同时include目录下还有*.ic的文件，这个文件中存放定义的内联函数。\n如果要在*.ic中使用宏UNIV_INLINE定义内联，需要#include \u0026ldquo;univ.i\u0026rdquo;，即\n#include \u0026#34;univ.i\u0026#34;UNIV_INLINE return_value function foo(param1, ...) ``// 函数声明或实现 { ``... } 注意，这种风格只是适用于c函数，对于ic文件中的类成员函数定义，还是需要手动写inline  univ.i中UNIV_INLINE的宏定义\n#ifndef UNIV_MUST_NOT_INLINE /* Definition for inline version */ #define UNIV_INLINE static inline #else /* !UNIV_MUST_NOT_INLINE *//* If we want to compile a noninlined version we use the following macro definitions: */ #define UNIV_NONINL #define UNIV_INLINE #endif /* !UNIV_MUST_NOT_INLINE */阅读源码层次\n推荐从下至上进行逐层阅读\n最下一层是基础管理模块：\n File Manager主要封装了InnoDB对于文件的各类操作，如读、写、异步I/O等。 Concurrency Manager模块主要封装了引擎内部使用的各类mutex和latch。 Common Utility模块用于一些基本数据结构与算法的定义，如链表、哈希表等。  图中间虚线标注的部分为InnoDB的内核实现，也就是InnoDB存储引擎中的事务、锁、缓冲区、日志、存储管理、资源管理、索引、change buffer模块，这部分是整个存储引擎的核心。\n图最上面的两层是接口层，通过这些接口实现server层与存储引擎的交互。InnoDB存储引擎可以不依赖MySQL数据库，而作为一个嵌入式数据库存在，因此还存在嵌入式的API接口。\n详细的目录（模块）说明如下：\n   目录 说明 文件      ut 基本数据结构和算法 ut0byteut0crc32ut0dbgut0listut0lstut0memut0newut0rbtut0rndut0vecut0wqueue 内存双向链表 ib_list内存双向链表 ut_list   mem 内存管理 mem0mem 内存管理   os 进程控制 univos0atomicos0eventos0fileos0procos0thread 定义了POD、编译器hint、代码段宏Atomic Read-Modify-WriteOS Event getpid、大页分配内存PSI key、进程控制原语   sync 同步机制 ut0mutexsync0arrsync0debugsync0rwsync0syncsync0policy 定义了mutex的宏、mutex_init()和mutex_destroy()、MutexMonitor MutexDebug   log 日志及恢复 log0loglog0recv 重做日志恢复   mtr mini-transaction mtr0typemtr0mtrmtr0logdyn0buf mtr相关定义mtr基本操作mtr日志操作mtr_buf_t   fsp 存储管理 fsp0filefsp0fspfsp0spacefsp0sysspace 数据文件物理文件结构与实现表空间系统表空间   fil 文件管理 fil0filos0file 文件内存数据结构及相关文件操作底层文件操作实现   fut  fut0lstfut0fut 磁盘双向链表 flst   data 逻辑记录 data0datadata0typedata0types 逻辑记录逻辑记录的操作逻辑记录数据结构   rem 物理记录 rem0recrem0cmprem0types 物理记录物理记录的比较物理记录数据结构   page 索引页 page0curpage0pagepage0typespage0sizepage0zip 索引页中记录的定位、插入、删除索引页的维护类型定义   lock 锁 lock0locklock0iterlock0prdtlock0waitlock0typeslock0priv 锁模式   btr B+树 btr0btrbtr0bulkbtr0curbtr0pcurbtr0sea    buf 缓冲池 buf0buddybuf0bufbuf0checksumbuf0dblwrbuf0dumpbuf0flubuf0lrubuf0rea    dict 数据字典 dict0bootdict0creadict0dictdict0loaddict0memdict0statsdict0stats_bg    ibuf change buffer ibuf0ibuf    row  row0extrow0ftsortrow0importrow0insrow0logrow0mergerow0mysqlrow0purgerow0quiescerow0rowrow0selrow0truncrow0uninsrow0umodrow0undorow0updrow0vars    trx 事务 trx0i_strx0purgetrx0rectrx0rolltrx0rsegtrx0systrx0trxtrx0undo    handler  ha_innodbha_innoparthandler0alteri_s    read  read0read    api  api0apiapi0misc    eval  eval0evaleval0misc    ha  ha0haha0storagehash0hash    mach  mach0data    pars  lexyypars0grmpars0lexpars0optpars0parspars0sym    que  que0que    srv  srv0concsrv0monsrv0srvsrv0start    usr  usr0sess    gis  gis0geogis0rtreegis0sea    fts  fts0astfts0blexfts0configfts0ftsfts0optfts0parsfts0pluginfts0quefts0sqlfts0tlex        目录 文件 说明     fut fut0fut File-based utilities   fu0lst File-based list utilities    ha ha0ha The hash table with external chains   ha0storage Hash storage    hash0hash The simple hash table utility    mem mem0mem The memory management   ut ut0byte Byte utilities        ut0crc32 CRC32    ut0dbg Debug utilities for Innobase.    ut0list A double-linked list    ut0mem Memory primitives    ut0new Instrumented memory allocator.    ut0rbt Red-Black tree implementation    ut0rnd Random numbers and hashing    ut0ut Various utilities for Innobase.    ut0vec A vector of pointers to data items    ut0wqueue work queue.          db0err Error Codes\neval\nFile Name What Name Stands For Size Comment Inside File --------- -------------------- ------ ------------------- eval0eval.c Evaluating/Evaluating 17,061 SQL evaluator eval0proc.c Evaluating/Procedures 5,001 Executes SQL procedures The evaluating step is a late part of the process of interpreting an SQL statement \u0026mdash; parsing has already occurred during \\pars (PARSING).\nThe ability to execute SQL stored procedures is an InnoDB feature, but MySQL handles stored procedures in its own way, so the eval0proc.c program is unimportant.\n代码风格 #  InnoDB的代码缩进风格更接近于K\u0026amp;R风格：所有的非函数语句块（if、switch、for、while、do），起始大括号放在行尾，而把结束大括号放在行首。函数开头的左花括号放到最左边。\n此外，每个文件都包含一段简短说明其功能的注释开头，同时每个函数也注释说明函数的功能，需要哪些种类的参数，参数可能值的含义以及用途。最后，对于变量的声明，使用下画线以分隔单词，坚持使用小写，并把大写字母留给宏和枚举常量。\n"},{"id":3,"href":"/docs/MySQL/InnoDB/5_record/","title":"5 Record","section":"Inno Db","content":"设计 #  MySQL主要面向的是OLTP场景，所以数据记录采用行存（NSM - n-ary storage model）。\n基于行进行存储有以下几个好处：\n 记录存放在一个页中，存储一条记录需要访问的页面较少 符合传统机械硬盘的访问方式 易于理解，数据的存取就像是对一张二维表进行访问  在整体上看，表中的数据是按照如下形式组织的：\n那我们如何来理解记录呢？\n首先，在关系数据库系统理论中，通常用元组（tuple）描述记录，用字段（field）描述列，每个元组由多个字段组成，每个表由多个元组组成。\n行和元组在意义上是相等的。但是更愿意将行（row）理解为物理记录，将元组（tuple）理解为逻辑记录。物理记录为行实际存放在物理存储中的格式，其内容由二进制字符串组成，可读性差。逻辑记录则容易理解的多，每张表中的多个记录就像是一个数组。由于其只是“逻辑”上的含义，因此逻辑记录只是物理记录在内存中的表现形式，实际并不占用任何的物理存储空间。\n关系如下图所示：\n物理记录和逻辑记录的差异如下：\n    物理记录 逻辑记录     可读性 差 好   存储位置 磁盘 内存   亲和性 对存储友好（更紧凑） 对查找友好（更易寻址）   存储内容 除记录中的列数据外，还有一些额外信息 元组    这两种记录之间本身可以互相转换。比如，在插入一条记录时，原来没有数据，首先需要根据插入的记录构造一个逻辑记录，然后再存放到磁盘上。对于读取，要从磁盘上seek出来相应的数据页，再将页中的物理记录转换成逻辑记录展现给用户。\n除此之外，在MySQL server层也需要在binlog中记录数据的变化，也需要一种行格式。因此，在MySQL中，行格式一共有3种存储方式：\n Server层格式：与存储引擎无关，server层的binlog行格式（Row-Base Replication下的binlog格式） 逻辑记录格式：tuple，也称为索引元组格式（因为InnoDB是IOT）。在同一个表中，不同索引对应的元组是不同的 物理记录格式：record，也称为physical record  物理记录的设计 #  物理记录承载着数据的最终存储，因此，我们首先讨论物理记录。\n磁盘上的物理记录需要面向计算机友好，更紧凑、强调IO性能，以及在此基础上支持事务语义。\n目标：\n 描述行存的数据 适配存储引擎的结构 查找快 DML快 事务语义 更少的资源占用（disk、buffer pool、update I/O）  逻辑记录的设计 #  磁盘上的物理记录面向的是计算机友好的，更紧凑、高IO性能。同时，为了性能的考虑，数据也需要常驻内存（buffer pool），所以需要设计数据结构用于表述记录，这被称为tuple（元组），也称为逻辑记录。\n实现 #  InnoDB存储引擎中的表使用的是索引组织表（Index Organized Table - IOT），这意味着表中的所有数据是按照B+树的方式进行存储的，行数据存在在B+树的叶子节点上，即使创建表时没有显式指定主键索引，也会自动创建一个6字节的隐藏列，用作主键索引。\n2.1 Redundant行格式 #  从上面我们可以得知，物理记录由3部分组成：\n2.1.1 sdfs #  sdfs\n"},{"id":4,"href":"/docs/MySQL/InnoDB/6_page/","title":"6 Page","section":"Inno Db","content":"索引页 #  InnoDB存储引擎是索引组织表，因此聚簇索引页的叶子节点中存放完整的数据记录，辅助索引页的叶子节点中存放指向聚簇索引页叶子节点的书签（bookmark），也可以称为路标。\n主要是两部分：\n page layout scan rec with cursor, and then insert, update, delete  1. 页 #  页是InnoDB存储引擎的最小存储单位。页的大小可以设置为4K、8K、16K、32K、64K，默认为16K，页的大小设置要考虑IO性能，也会影响到区的分配大小和重做日志缓冲的大小，详见innodb_page_size。\n"},{"id":5,"href":"/docs/MySQL/InnoDB/","title":"Inno Db","section":"MySQL","content":"InnoDB存储引擎 #  从InnoDB的发展历史作为起点，了解InnoDB一路走来的历程。\n然后在全局视角下先了解整体的模块构成及其功能。\n再按照以下的路径深入细节：\n 概览 源码结构 基本数据结构与算法 os records 索引页 storage management 同步机制 缓冲池 数据字典 B+树索引 change buffer lock 事务处理 mini-transaction redo log 服务管理 row  一路下来，应该已经对各个模块的功能和细节了然于心，然后再回头再重温一下整体架构，做到融会贯通。\n"},{"id":6,"href":"/docs/MySQL/Server/connection_handler/","title":"Connection Handler","section":"Server","content":"概述 #  在MySQL中，对于client发来的请求，其处理流程分为建链和请求处理两部分，这两个阶段分别称为connection phase和command phase。\nMySQL的server-client protocol交互如下：\n"},{"id":7,"href":"/docs/MySQL/Server/startup/","title":"Startup","section":"Server","content":"MySQL启动过程\nmain() // 入口 sql/main.cc mysqld_main() // sql/mysqld.cc // 记录入参 my_progname = argv[0]; orig_argc = argc; orig_argv = argv; // 处理配置文件my.cnf及启动参数 load_defaults(MYSQL_CONFIG_NAME, load_default_groups, \u0026amp;argc, \u0026amp;argv, \u0026amp;argv_alloc); // 继续处理启动参数，为初始化系统表做准备 sys_var::m_parse_flag == PARSE_EARLY handle_early_options(); // 为status统计计数做准备 init_sql_statement_names(); // 初始化system variables哈希表,链表sys_var_chain sys_var,遍历链表后,加入到system_variable_hash哈希表 // sys_var_chain链表已经通过sys_vars.cc的sys_var()构造函数static初始化 sys_var_init(); // 计算打开文件数并初始化table cache adjust_related_options(\u0026amp;requested_open_files); // init error log global variables init_error_log(); // init audit global variables mysql_audit_initialize(); // 初始化query log和slow log query_logger.init(); // 初始化system variables init_common_variables(); default_storage_engine= const_cast\u0026lt;char *\u0026gt;(\u0026quot;InnoDB\u0026quot;); // 设置默认storage engine add_status_vars(status_vars); // 初始化status变量(show status), status_vars为全局变量 set_server_version(); get_options(\u0026amp;remaining_argc, \u0026amp;remaining_argv); // sys_var::m_parse_flag == PARSE_NORMAL // 设置thread_cache_size init_client_errs(); // 读出给client返回出错信息的文件 lex_init(); // 初始化词法分析 item_create_init(); // 初始化函数列表 func_array为全局变量 // 设置默认字符集和校验字符集 global_system_variables.collation_connection= default_charset_info; global_system_variables.character_set_results= default_charset_info; global_system_variables.character_set_client= default_charset_info; // 设置默认storage engine lex_init(); // 初始化信号量 my_init_signals(); // 启动核心模块 init_server_components(); mdl_init();\t// mdl元数据锁 table_def_init(); // 表定义缓存 init_server_query_cache();\t// Query Cache init binlog relaylog\t// Binlog Relaylog gtid_server_init();\t// GTID plugin_register_builtin_and_init_core_se(); // Load builtin plugins, initialize MyISAM, CSV and InnoDB // 初始化并创建GTID init_server_auto_options(); // 初始化SSL init_ssl(); // 初始化网络 network_init(); // 创建PID文件 create_pid_file(); // 初始化status variables init_status_vars(); // binlog相关检查初始化 check_binlog_cache_size(NULL); check_binlog_stmt_cache_size(NULL); binlog_unsafe_map_init(); // 初始化Slave init_slave(); // 创建线程处理信号量 start_signal_handler(); // 如果是安装初始化，创建handle_bootstrap线程进行初始化datadir,系统表 if (opt_bootstrap) bootstrap(mysql_stdin); // 创建manager线程 start_handle_manager(); // 执行DDL crash recovery execute_ddl_log_recovery(); // 监听socket事件 mysqld_socket_acceptor-\u0026gt;connection_event_loop(); if (signal_thread_id.thread != 0) ret= my_thread_join(\u0026amp;signal_thread_id, NULL); clean_up(1); mysqld_exit(MYSQLD_SUCCESS_EXIT); 其中，load_defaults()会寻找my.cnf，并根据load_default_groups，使用search_default_file_with_ext()解析每一行配置，并进行标准化（配置项名称前加上\u0026ndash;）\n// sql/mysqld.cc 2325 const char *load_default_groups[]= { ... 2329 \u0026quot;mysqld\u0026quot;,\u0026quot;server\u0026quot;, MYSQL_BASE_VERSION, 0, 0}; // mysys_ssl/my_default.cc my_load_defaults my_search_option_files my_search_option_files search_default_file_with_ext 配置项会被handle_default_option()缓存在内存中\n// mysys_ssl/my_default.cc handle_default_option() struct handle_option_ctx { MEM_ROOT *alloc; My_args *m_args; TYPELIB *group; }; "},{"id":8,"href":"/menu/","title":"Index","section":"Rick's Blog","content":" MySQL  Server  MySQL启动过程 MySQL的连接和请求处理 Thread Pool   InnoDB  概览 源码结构 基本数据结构和算法 os record page      "}]